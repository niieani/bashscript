{"version":3,"sources":["webpack:///./src/util/flatmap.js","webpack:///./src/util/array.ts","webpack:///./src/writer/scope-proxy.ts","webpack:///./src/writer/context.ts","webpack:///./src/writer/syntax/raw.ts","webpack:///./src/writer/context-util.ts","webpack:///./src/writer/reducers.ts","webpack:///./src/writer/syntax/starter.ts","webpack:///./src/writer/writer.ts","webpack:///./src/writer/scope.ts","webpack:///./src/util/visitor.ts","webpack:///./src/util/flatmap-simple.ts","webpack:///./src/writer/syntax/comment-util.ts","webpack:///./src/writer/syntax/terminator.ts","webpack:///./src/writer/syntax/comment.ts","webpack:///./src/util/ast.ts","webpack:///./src/writer/statement.ts","webpack:///./src/writer/syntax/parts.ts","webpack:///./src/visitors.ts","webpack:///./repl/transpile.ts","webpack:///./src/util/test-util.ts","webpack:///./src/transpile.ts"],"names":["flattenIntoArray","target","source","start","depth","mapper","thisArg","targetIndex","sourceIndex","sourceLen","toLength","length","P","spreadable","element","call","Symbol","isConcatSpreadable","Array","isArray","TypeError","arraySpeciesCreate","original","RangeError","C","constructor","prototype","undefined","species","arg","Math","min","isNaN","floor","ceil","toInteger","toObject","Object","flatMap","defineProperty","enumerable","value","callback","O","this","A","flatten","Infinity","Number","combineAlternate","arr1","arr2","noLengthCheck","flipOrder","reduce","combined","arr1value","index","findLastIndex","predicate","arr","result","slice","reverse","findIndex","ensureArray","maybeArray","createScopeProxy","scope","Proxy","get","property","receiver","calls","type","data","toString","context","parts","emptyContext","partsToExtract","processed","scopePath","parent","ctx","indent","__rest","s","e","t","p","hasOwnProperty","indexOf","getOwnPropertySymbols","i","raw","text","_a","assign","shouldTreatAsPureText","textOrAST","coerceStringToAST","astGroup","children","reduceAST","ensureASTObject","node","map","scopeHelper","reducers_rest","defaultReduce","nextContext","defineReducer","reducer","ast","astParent","parentSkipType","isSkipType","newContext","newLine","starter","[object Object]","padStart","ensureStarter","_context","token","array","array_last","isBeginningOfLine","print","join","asObject","addToScopeAndWrite","name","as","safeName","asName","append","addToScopeAndReplaceUsage","usage","usageText","extractedToRootScope","body","extractedContext","getNameGenerator","wrapper","flatmapSimple","nestedArray","concat","getInlineComments","objects","filter","obj","terminator","sinceLastTerminator","contentSincePreviousTerminator","comments","commentText","comment","lastTerminatorAt","previousTerminatorIndex","comment_comment","withSpace","getCommentObjects","getComments","compilerNode","commentPart","getFullText","getLeadingTriviaWidth","acorn_es","ranges","onComment","allowHashBang","split","statement_ast","strings","every","part","from","statement","applied","first","rest","last","declareVariable","initializer","variable","declare","referenceVar","declareFunction","scopeDescription","innerContext","inIsolatedScope","unsupportedVisitor","getText","line","padEnd","getKindName","nodeVisitor","rootScope","getKind","typescript","ExpressionStatement","expression","getChildAtIndex","CallExpression","identNode","getExpression","argNodes","getArguments","callable","args","argCommentsList","argComments","argsRaw","callExpressionVisitor","expressionVisitor","FunctionDeclaration","getName","params","getParameters","param","getType","transformedStatements","getStatements","getNameFromScope","functionStatements","functionVisitor","VariableStatement","getDeclarationList","getDeclarations","declaration","getInitializer","StringLiteral","variableStatementVisitor","ImportDeclaration","importFrom","getModuleSpecifierValue","getNamedImports","member","importDeclarationVisitor","fileVisitor","EndOfFileToken","SyntaxList","getChildren","transpileText","file","fileContents","main_default","a","useVirtualFileSystem","addFilesFromTsConfig","compilerOptions","strict","noLib","createSourceFile","statements","transpile"],"mappings":"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","file":"3.bundle.js","sourcesContent":["// from https://gist.github.com/Kovensky/921c58de0c58be01aebf06d86cf9692f\n\nif (typeof Array.prototype.flatMap !== 'function') {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'flatMap', {\n    enumerable: false,\n    // https://bterlson.github.io/proposal-flatMap/#sec-Array.prototype.flatMap\n    value: function flatMap (callback, thisArg = undefined) {\n      const O = toObject(this)\n      const A = arraySpeciesCreate(O, 0)\n      // typo in the github pages render, it's missing\n      // the \", 1\" argument, but it is present in\n      // the master source code\n      flattenIntoArray(A, O, 0, 1, callback, thisArg)\n      return A\n    }\n  })\n}\n\nif (typeof Array.prototype.flatten !== 'function') {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Array.prototype, 'flatten', {\n    enumerable: false,\n    // https://bterlson.github.io/proposal-flatMap/#sec-Array.prototype.flatten\n    value: function flatten (depth = Infinity) {\n      const O = toObject(this)\n      const A = arraySpeciesCreate(O, 0)\n      depth = Number(depth)\n      flattenIntoArray(A, O, 0, depth)\n      return A\n    }\n  })\n}\n\n// https://bterlson.github.io/proposal-flatMap/#sec-FlattenIntoArray\nfunction flattenIntoArray (target, source, start, depth, mapper, thisArg) {\n  let targetIndex = start\n  let sourceIndex = 0\n  const sourceLen = toLength(source.length)\n\n  while (sourceIndex < sourceLen) {\n    const P = `${sourceIndex}`\n    if (P in source) {\n      let element = source[P]\n      if (mapper) {\n        element = mapper.call(thisArg, element, sourceIndex, target)\n      }\n      let spreadable\n      // https://tc39.github.io/ecma262/#sec-isconcatspreadable\n      if (typeof element !== 'object') {\n        spreadable = false\n      } else {\n        spreadable = element[Symbol.isConcatSpreadable]\n        if (typeof spreadable !== 'undefined') {\n          spreadable = !!spreadable\n        } else {\n          spreadable = Array.isArray(element)\n        }\n      }\n\n      // spec deviation: the spec specifies \"depth >= 0\",\n      // but that incorrectly flattens one level too far.\n      // https://github.com/bterlson/proposal-flatMap/issues/11\n      if (spreadable && depth > 0) {\n        const nextIndex = flattenIntoArray(target, element, targetIndex, depth - 1)\n        // spec deviation: decrement targetIndex by 1 here\n        // it will get incremented back at the tail of the loop\n        // https://github.com/bterlson/proposal-flatMap/issues/13\n        targetIndex = nextIndex - 1\n      } else {\n        if (targetIndex !== toLength(targetIndex)) {\n          throw TypeError()\n        }\n        target[targetIndex] = element\n      }\n    }\n    targetIndex += 1\n    sourceIndex += 1\n  }\n  return targetIndex\n}\n\n// https://tc39.github.io/ecma262/#sec-arrayspeciescreate\nfunction arraySpeciesCreate (original, length) {\n  length = toLength(length)\n  if (length < 0) {\n    throw new RangeError()\n  }\n\n  let C\n  if (!Array.isArray(original)) {\n    C = original.constructor\n\n    // Trick to implement the Realm check\n    // from core-js\n    if (typeof C === 'function' &&\n      (C === Array || Array.isArray(C.prototype))) {\n      C = undefined\n    }\n\n    if (typeof C === 'object' ? C !== null : typeof C === 'function') {\n      C = C[Symbol.species]\n      if (C === null) {\n        C = undefined\n      }\n    }\n  }\n\n  if (typeof C === 'undefined') {\n    C = Array\n  }\n\n  return new C(length)\n}\n\n// These are more-or-less like the core-js implementations\n// in modules/_to-{length,integer,object}\n\nfunction toLength (arg) {\n  return arg > 0 ? Math.min(toInteger(arg), 0x1fffffffffffff) : 0\n}\n\nfunction toInteger (arg) {\n  arg = +arg\n  return isNaN(arg) ? 0 : (arg > 0 ? Math.floor : Math.ceil)(arg)\n}\n\nfunction toObject (arg) {\n  if (arg === undefined) {\n    throw new TypeError(`Can't call method on ${arg}`)\n  }\n  return Object(arg)\n}\n","/**\n * Combines two arrays by alternating their indices\n * combineAlternate([a, b, c], [1, 2, 3]) === [a, 1, b, 2, c, 3]\n */\nexport const combineAlternate = (arr1, arr2, noLengthCheck = false, flipOrder = false) => noLengthCheck || arr1.length >= arr2.length\n    ? arr1.reduce((combined, arr1value, index) => index < arr2.length\n        ? [\n            ...combined,\n            ...(flipOrder\n                ? [arr2[index], arr1value]\n                : [arr1value, arr2[index]]),\n        ]\n        : [...combined, arr1value], [])\n    : combineAlternate(arr2, arr1, true, true);\nexport const findLastIndex = (predicate) => (arr) => {\n    const result = arr\n        .slice()\n        .reverse()\n        .findIndex(predicate);\n    return result >= 0 ? arr.length - 1 - result : result;\n};\nexport const last = (array) => array.slice().reverse()[0];\nexport const ensureArray = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n","export const createScopeProxy = (scope = {}) => new Proxy(scope, {\n    get: function (target, property, receiver) {\n        if (property in target) {\n            return target[property];\n        }\n        // workaround for jest:\n        if (property === 'getMockName')\n            return (() => 'Scope');\n        if (property === 'mock')\n            return { calls: [] };\n        return {\n            type: 'unknown',\n            data: {},\n            length: property.toString().length,\n            reduce: (context) => context,\n            parts: [],\n            toString: () => property.toString(),\n        };\n    },\n});\n","import { createScopeProxy } from './scope-proxy';\nexport const astRoot = {\n    type: 'root',\n    data: {},\n    reduce: (ctx) => ctx,\n};\nexport const emptyContext = {\n    parts: [],\n    partsToExtract: [],\n    processed: [],\n    scopePath: [],\n    scope: createScopeProxy(),\n    parent: astRoot,\n    indent: 0,\n};\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nexport const raw = (text) => ({\n    reduce: function reduce(_a) {\n        var { processed, parts } = _a, context = __rest(_a, [\"processed\", \"parts\"]);\n        return Object.assign({}, context, { processed: [...processed, this], parts: [...parts, text] });\n    },\n    parts: [text],\n    data: { text },\n    type: 'raw',\n});\n","import { raw } from './syntax/raw';\nimport { reduceAST } from './reducers';\nimport { emptyContext } from './context';\nimport { scopeHelper } from './scope';\nexport const shouldTreatAsPureText = (textOrAST) => typeof textOrAST === 'string' || textOrAST.hasOwnProperty('toString');\nexport const coerceStringToAST = (textOrAST) => shouldTreatAsPureText(textOrAST) ? raw(textOrAST) : textOrAST;\nexport const astGroup = (...children) => ({\n    type: 'group',\n    data: { children },\n    reduce: (context) => reduceAST(children, context),\n});\nexport const ensureASTObject = (node, context = emptyContext) => Array.isArray(node)\n    ? astGroup(...node.flatten(100).map(coerceStringToAST))\n    : typeof node === 'function'\n        ? ensureASTObject(node(scopeHelper(context)), context)\n        : coerceStringToAST(node);\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport { emptyContext } from './context';\nimport { ensureASTObject } from './context-util';\nexport function defaultReduce(context) {\n    const _a = reduceAST(this.parts || [], context), { processed } = _a, nextContext = __rest(_a, [\"processed\"]);\n    return Object.assign({}, nextContext, { processed: [...processed, this] });\n}\nexport const defineReducer = ({ reducer, data, }) => Object.assign(reducer, { data });\nexport const isSkipType = (type) => {\n    switch (type) {\n        case 'enhance':\n        case 'group':\n            return true;\n        default:\n            return false;\n    }\n};\nexport const reduceAST = (ast, _a = emptyContext) => {\n    var { parent: astParent } = _a, context = __rest(_a, [\"parent\"]);\n    return ast.reduce((context, node) => {\n        const parent = ensureASTObject(node, context);\n        const parentSkipType = isSkipType(parent.type) ? context.parent : parent;\n        const newContext = parent.reduce(Object.assign({}, context, { parent: parentSkipType }));\n        return Object.assign({}, newContext, { parent: astParent });\n    }, Object.assign({}, context, { parent: astParent }));\n};\n","import { findLastIndex, last } from '../../util/array';\nexport const newLine = '\\n';\nexport const semi = '; ';\n// TODO: should we differentiate start of content flow (terminated by \\n) vs inline content (a; b;)?\n/**\n * marks the start of a new statement in indented content flow\n */\nexport const starter = {\n    type: 'starter',\n    data: {},\n    reduce(context) {\n        const { processed, parts, indent } = context;\n        return Object.assign({}, context, { parts: indent ? [...parts, ''.padStart(indent)] : parts, processed: [...processed, this] });\n    },\n};\nexport const lastStarterAt = findLastIndex(({ type }) => type === 'starter');\nexport const isBeginningOfLine = (context) => {\n    const token = last(context.parts);\n    return !token || token === newLine;\n};\nexport const ensureStarter = ({ _context: context }) => context.indent > 0 && isBeginningOfLine(context) ? starter : '';\n","import { emptyContext } from './context';\nimport { reduceAST } from './reducers';\nimport { ensureArray } from '../util/array';\nexport const print = (ast, context = emptyContext) => {\n    const { partsToExtract, parts } = reduceAST(ensureArray(ast), context);\n    return [...partsToExtract, ...parts].join('');\n};\n","import { ensureArray } from '../util/array';\nimport { defineReducer, reduceAST } from './reducers';\nimport { newLine } from './syntax/starter';\nimport { createScopeProxy } from './scope-proxy';\nimport { print } from './writer';\nexport const asObject = (reduce) => ({\n    type: 'enhance',\n    data: reduce.data,\n    reduce,\n});\n/**\n * adds a variable to scope and prints its name\n */\nexport const addToScopeAndWrite = (name, as) => asObject(defineReducer({\n    data: { name },\n    reducer: (context) => {\n        const { scope, parts, parent } = context;\n        let safeName = name;\n        if (as) {\n            const { parts: asName } = reduceAST(ensureArray(as), Object.assign({}, context, { parts: [] }));\n            safeName = asName.join('') || name;\n        }\n        let append = 0;\n        while (safeName in scope) {\n            append++;\n            // we need to rename this variable\n            safeName = `${name}_${append}`;\n        }\n        return Object.assign({}, context, { parent, parts: [...parts, safeName], scope: createScopeProxy(Object.assign({}, scope, { [name]: Object.assign({}, parent, { toString: () => safeName, length: safeName.length }) })) });\n    },\n}));\nexport const addToScopeAndReplaceUsage = (name, usage) => asObject(defineReducer({\n    data: { name, usage },\n    reducer: (context) => {\n        const { scope, parent } = context;\n        const usageText = print(usage, Object.assign({}, context, { parts: [] }));\n        return Object.assign({}, context, { scope: createScopeProxy(Object.assign({}, scope, { [name]: Object.assign({}, parent, { toString: () => usageText, length: usageText.length }) })) });\n    },\n}));\n/**\n * in scopes { ... } and sub-shells ( ... ) we \"fork\" context\n * i.e. ignore its result down the line\n */\nexport const inIsolatedScope = (body, scopeDescription) => asObject(defineReducer({\n    reducer: (context) => {\n        const { indent, processed, scope, scopePath, parent, partsToExtract, parts, } = context;\n        const innerContext = reduceAST(ensureArray(body), Object.assign({}, context, { indent: indent + 2, scopePath: [...scopePath, scopeDescription], processed: [], parts: [], partsToExtract: [] }));\n        return Object.assign({}, context, { partsToExtract: [...partsToExtract, ...innerContext.partsToExtract], parts: [...parts, ...innerContext.parts], processed: [...processed, parent, ...innerContext.processed] });\n    },\n    data: { scopeDescription, body },\n}));\nexport const extractedToRootScope = (body) => asObject(defineReducer({\n    reducer: (context) => {\n        const { indent, processed, scope, scopePath, parent, partsToExtract, parts, } = context;\n        const extractedContext = reduceAST(ensureArray(body), Object.assign({}, context, { indent: 0, parts: [], partsToExtract: [] }));\n        return Object.assign({}, context, { partsToExtract: [\n                ...partsToExtract,\n                // we move normal parts to extracted ones:\n                ...extractedContext.parts,\n                ...extractedContext.partsToExtract,\n                newLine,\n            ], parts, processed: extractedContext.processed });\n    },\n    data: { body },\n}));\nexport const scopeHelper = (context) => (Object.assign({}, context.scope, { _context: context }));\n","export const passthrough = (t) => t;\nexport const getNameGenerator = (name) => (wrapper = passthrough) => ({ _context: { scopePath } }) => wrapper(`${scopePath.join('.')}.${name}`);\n","export const flatmapSimple = (nestedArray) => [].concat(...nestedArray);\n","export const getInlineComments = (objects) => objects.filter((obj) => obj.type === 'comment-inline');\n","import { newLine } from './starter';\nimport { findLastIndex } from '../../util/array';\nimport { getInlineComments } from './comment-util';\nexport const terminator = {\n    type: 'terminator',\n    data: {},\n    reduce: terminatorReduce,\n};\nexport const lastTerminatorAt = findLastIndex(({ type }) => type === 'terminator');\nexport const contentSincePreviousTerminator = ({ processed }) => {\n    const previousTerminatorIndex = lastTerminatorAt(processed);\n    return previousTerminatorIndex >= 0\n        ? processed.slice(previousTerminatorIndex)\n        : processed;\n};\nexport function terminatorReduce(context) {\n    const { processed, parts } = context;\n    const sinceLastTerminator = contentSincePreviousTerminator(context);\n    const comments = getInlineComments(sinceLastTerminator);\n    const commentText = `# ${comments\n        .map(({ data: { comment: text } }) => text)\n        .join(' | ')}`;\n    return Object.assign({}, context, { processed: [...processed, this], parts: comments.length\n            ? [...parts, newLine, commentText]\n            : [...parts, newLine] });\n}\n","import { ensureStarter } from './starter';\nimport { terminator } from './terminator';\nimport { defaultReduce } from '../reducers';\nexport const comment = (comment, withSpace = true) => ({\n    reduce: defaultReduce,\n    type: 'comment',\n    parts: [ensureStarter, `#${withSpace ? ' ' : ''}${comment}`, terminator],\n    data: { comment },\n});\n","import * as acorn from 'acorn';\nimport { comment } from '../writer/syntax/comment';\nexport const getCommentObjects = (node) => getComments(node).map((text) => comment(text, false));\nexport const getComments = ({ compilerNode }) => {\n    const commentPart = compilerNode\n        .getFullText()\n        .slice(0, compilerNode.getLeadingTriviaWidth());\n    const comments = [];\n    acorn.parse(commentPart, {\n        ranges: false,\n        onComment: comments,\n        allowHashBang: true,\n    });\n    return comments.map((comment) => `${comment.value.split('\\n').join('\\n#')}`);\n};\n","import { starter } from './syntax/starter';\nimport { terminator } from './syntax/terminator';\nimport { combineAlternate } from '../util/array';\nimport { coerceStringToAST, shouldTreatAsPureText } from './context-util';\nimport { astGroup } from './context-util';\nimport { ensureASTObject } from './context-util';\n/**\n * Template string for creating AST from nodes/strings and functions\n */\nexport const ast = (strings, ...parts) => parts.every((part) => typeof part !== 'function')\n    ? combineAlternate(Array.from(strings), parts.flatten(1))\n        .filter((node) => node !== undefined &&\n        (!shouldTreatAsPureText(node) || node.length > 0))\n        .map(coerceStringToAST)\n    : [\n        astGroup(({ _context: context }) => ensureASTObject(combineAlternate(Array.from(strings).map(coerceStringToAST), parts\n            .filter((part) => typeof part !== 'undefined')\n            .map((part) => ensureASTObject(part, context))), context)),\n    ];\n/**\n * a template string literal function for writing complete expressions\n */\nexport const statement = (strings, ...parts) => {\n    const applied = ast(strings, ...parts);\n    const [first, ...rest] = applied;\n    const [last] = rest.reverse();\n    return [\n        ...(first && first.type !== 'starter' ? [starter] : []),\n        ...applied,\n        ...(!last || last.type !== 'terminator' ? [terminator] : []),\n    ];\n};\n","import { defaultReduce } from '../reducers';\nimport { starter } from './starter';\nimport { ast, statement } from '../statement';\nimport { addToScopeAndWrite, inIsolatedScope } from '../scope';\nexport const declare = (variable, initializer) => ({\n    parts: initializer !== undefined\n        ? statement `declare ${variable}=${initializer}`\n        : statement `declare ${variable}`,\n    type: 'declaration',\n    data: { variable, initializer },\n    reduce: defaultReduce,\n});\nexport const declareVariable = (name, initializer) => declare(addToScopeAndWrite(name), initializer);\nexport const referenceVar = (name) => ({\n    type: 'variable',\n    parts: [ast `\\${${name.toString()}}`],\n    data: { name },\n    reduce: defaultReduce,\n});\nexport const declareFunction = ({ name, body, as, }) => ({\n    type: 'function',\n    data: { name, body, as },\n    reduce: defaultReduce,\n    parts: statement `function ${addToScopeAndWrite(name, as)} {\n${inIsolatedScope(body, name)}${starter}}`,\n});\nconst functionCall = ({ name, args, comments, }) => ({\n    type: 'call',\n    data: { name, args, comments },\n    reduce: defaultReduce,\n    parts: statement `${(ctx) => ctx[name] || name} ${args}${comments && ` # ${comments}`}`\n});\n","import './util/flatmap';\nimport * as ts from 'typescript';\nimport { addToScopeAndReplaceUsage, extractedToRootScope } from './writer/scope';\nimport { getNameGenerator } from './util/visitor';\nimport { flatmapSimple } from './util/flatmap-simple';\nimport { getCommentObjects } from './util/ast';\nimport { declareFunction, declareVariable, referenceVar, } from './writer/syntax/parts';\nimport { comment } from './writer/syntax/comment';\nimport { ast, statement } from './writer/statement';\nexport function unsupportedVisitor(node) {\n    return [\n        ...getCommentObjects(node),\n        ...node\n            .getText()\n            .split('\\n')\n            .map((line) => comment(`<unsupported> ${line.padEnd(40, ' ')} # ${node.getKindName()}`)),\n    ];\n}\nexport function genericNodeVisitor(node, rootScope = true) {\n    switch (node.getKind()) {\n        case ts.SyntaxKind.ExpressionStatement:\n            return expressionVisitor(node);\n        case ts.SyntaxKind.FunctionDeclaration:\n            return functionVisitor(node, rootScope);\n        case ts.SyntaxKind.VariableStatement:\n            return variableStatementVisitor(node);\n        case ts.SyntaxKind.ImportDeclaration:\n            return importDeclarationVisitor(node);\n        default:\n            return unsupportedVisitor(node);\n    }\n}\nexport let nodeVisitor = genericNodeVisitor;\nexport const setNodeVisitor = (visitor) => {\n    nodeVisitor = visitor;\n};\nexport function functionVisitor(node, rootScope = true) {\n    // const body = node.getBody() as AST.Block | undefined\n    // if (!body) return empty\n    const name = node.getName();\n    const paramNodes = node.getParameters();\n    const params = paramNodes.map((param, index) => {\n        const name = param.getName() || '_';\n        const type = param.getType();\n        // console.log(type.getText())\n        return declareVariable(name, referenceVar(index + 1));\n        // return `local ${name}=\"$${index+1}\"`\n    });\n    const innerStatements = node.getStatements();\n    const transformedStatements = innerStatements\n        .map((node) => nodeVisitor(node, false))\n        .flatten(1);\n    const getNameFromScope = getNameGenerator(name);\n    const functionStatements = [\n        ...getCommentObjects(node),\n        declareFunction({\n            name,\n            as: rootScope ? name : getNameFromScope(),\n            body: [...params, ...transformedStatements],\n        }),\n    ];\n    return rootScope\n        ? functionStatements\n        : ast `${extractedToRootScope(functionStatements)}${getNameFromScope((name) => comment(`function declaration extracted, see: ${name}`))}`;\n}\nexport function expressionVisitor(node) {\n    const expression = node.getChildAtIndex(0);\n    // console.log(expression)\n    switch (expression.getKind()) {\n        case ts.SyntaxKind.CallExpression:\n            return [\n                ...getCommentObjects(node),\n                ...callExpressionVisitor(expression),\n            ];\n        // const callExpr = expression as AST.CallExpression\n        default:\n            return unsupportedVisitor(node);\n    }\n}\nexport function callExpressionVisitor(node) {\n    const identNode = node.getExpression();\n    const argNodes = node.getArguments();\n    const callable = identNode.getText();\n    // TODO: map args depending on their type, i.e. passthrough StringLiteral\n    const args = argNodes.map((arg) => arg.getText());\n    const argCommentsList = flatmapSimple(argNodes.map((arg) => getCommentObjects(arg)));\n    const hasComments = argCommentsList.length > 0;\n    const argComments = hasComments ? ` # ${argCommentsList.join(', ')}` : '';\n    const argsRaw = args.join(' ');\n    // TODO: functionCall({})\n    return statement `${(ctx) => ctx[callable] || callable}${argsRaw.length ? ` ${argsRaw}` : ''}${argComments}`;\n}\nexport function fileVisitor(node) {\n    switch (node.getKind()) {\n        case ts.SyntaxKind.EndOfFileToken:\n            return [];\n        case ts.SyntaxKind.SyntaxList:\n        default:\n            const list = node;\n            return list\n                .getChildren()\n                .map((node) => nodeVisitor(node, true))\n                .flatten(1);\n    }\n}\nexport function importDeclarationVisitor(node) {\n    // return unsupportedVisitor(node)\n    const importFrom = node.getModuleSpecifierValue();\n    const importedMembers = node.getNamedImports();\n    return importedMembers.map((member) => {\n        const name = member.getName();\n        return addToScopeAndReplaceUsage(name, `@module \"${importFrom}\" ${name}`);\n    }).flatten(1);\n    // return importedMembers.map((member) => {\n    //   const name = member.getName()\n    //   return statement`${addToScopeAndReplaceUsage(name, `@module \"${importFrom}\" ${name}`)}`\n    // }).flatten(1)\n}\nexport function variableStatementVisitor(node) {\n    const list = node.getDeclarationList();\n    const declarations = list.getDeclarations();\n    return declarations.map((declaration) => {\n        const name = declaration.getName();\n        const initializer = declaration.getInitializer();\n        let value = undefined;\n        if (initializer) {\n            switch (initializer.getKind()) {\n                case ts.SyntaxKind.StringLiteral:\n                    value = initializer.getText();\n                    break;\n                default:\n                    value = comment(`Unsupported initializer type: ${initializer.getKindName()}`);\n                    break;\n            }\n        }\n        return declareVariable(name, value);\n    });\n}\n// AST\n","import './index.css';\nimport { makeTestFile } from '../src/util/test-util';\nimport { transpile } from '../src/transpile';\nexport const transpileText = (text) => {\n    const file = makeTestFile(text);\n    try {\n        return transpile(file);\n    }\n    catch (_a) {\n        return undefined;\n    }\n};\n","import Ast from 'ts-simple-ast';\nexport const makeTestFile = (fileContents) => {\n    const project = new Ast({\n        useVirtualFileSystem: true,\n        addFilesFromTsConfig: false,\n        compilerOptions: {\n            strict: true,\n            noLib: true,\n        },\n    });\n    return project.createSourceFile('main.ts', fileContents);\n};\n","import { fileVisitor } from './visitors';\nimport { print } from './writer/writer';\nexport function transpile(source) {\n    if (!source) {\n        return '';\n    }\n    // ordered statements in the file\n    // function call is a statement, function definition is a statement, etc.\n    const children = source.getChildren();\n    const statements = children.map(fileVisitor).flatten(1);\n    return print(statements);\n}\n"],"sourceRoot":""}