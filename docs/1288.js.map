{"version":3,"sources":["webpack://bashscript/./node_modules/@ts-morph/common/node_modules/typescript/lib|sync","webpack://bashscript/./src/util/test-util.ts","webpack://bashscript/./src/util/array.ts","webpack://bashscript/./src/writer/scope-proxy.ts","webpack://bashscript/./src/writer/context.ts","webpack://bashscript/./src/writer/syntax/raw.ts","webpack://bashscript/./src/writer/context-util.ts","webpack://bashscript/./src/writer/reducers.ts","webpack://bashscript/./src/writer/syntax/starter.ts","webpack://bashscript/./src/writer/writer.ts","webpack://bashscript/./src/writer/scope.ts","webpack://bashscript/./src/util/visitor.ts","webpack://bashscript/./src/writer/syntax/terminator.ts","webpack://bashscript/./src/writer/syntax/comment-util.ts","webpack://bashscript/./src/writer/syntax/comment.ts","webpack://bashscript/./src/util/ast.ts","webpack://bashscript/./src/writer/statement.ts","webpack://bashscript/./src/writer/syntax/parts.ts","webpack://bashscript/./src/visitors.ts","webpack://bashscript/./src/util/flatmap-simple.ts","webpack://bashscript/./repl/transpile.ts","webpack://bashscript/./src/transpile.ts"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","combineAlternate","arr1","arr2","noLengthCheck","flipOrder","length","reduce","combined","arr1value","index","findLastIndex","predicate","arr","result","slice","reverse","findIndex","ensureArray","maybeArray","Array","isArray","createScopeProxy","scope","Proxy","get","target","property","receiver","calls","type","data","toString","context","parts","emptyContext","partsToExtract","processed","scopePath","parent","ctx","indent","raw","text","this","shouldTreatAsPureText","textOrAST","hasOwnProperty","coerceStringToAST","astGroup","children","reduceAST","ensureASTObject","node","flat","map","scopeHelper","defaultReduce","nextContext","defineReducer","reducer","Object","assign","ast","astParent","parentSkipType","isSkipType","starter","padStart","ensureStarter","_context","token","isBeginningOfLine","print","join","asObject","addToScopeAndWrite","name","as","safeName","asName","append","inIsolatedScope","body","scopeDescription","innerContext","passthrough","t","terminator","sinceLastTerminator","previousTerminatorIndex","lastTerminatorAt","contentSincePreviousTerminator","comments","objects","filter","obj","commentText","comment","withSpace","getCommentObjects","getComments","astNode","leading","getLeadingCommentRanges","trailing","getTrailingCommentRanges","getText","split","strings","every","part","from","undefined","statement","applied","first","rest","last","declareVariable","initializer","variable","declare","declareFunction","unsupportedVisitor","line","padEnd","getKindName","nodeVisitor","rootScope","getKind","expression","getChildAtIndex","callExpressionVisitor","expressionVisitor","getName","params","getParameters","param","getType","referenceVar","transformedStatements","getStatements","getNameFromScope","wrapper","getNameGenerator","functionStatements","extractedContext","functionVisitor","list","getDeclarationList","getDeclarations","declaration","getInitializer","value","variableStatementVisitor","importFrom","getModuleSpecifierValue","getNamedImports","member","usage","usageText","addToScopeAndReplaceUsage","importDeclarationVisitor","commentVisitor","identNode","getExpression","argNodes","getArguments","callable","args","arg","argCommentsList","nestedArray","concat","argComments","argsRaw","fileVisitor","getChildren","transpileText","file","fileContents","Project","useInMemoryFileSystem","addFilesFromTsConfig","compilerOptions","strict","noLib","createSourceFile","source","statements","transpile"],"mappings":"sFAAA,SAASA,EAAoBC,GAC5B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBF,EAAM,KAEjD,MADAC,EAAEE,KAAO,mBACHF,EAEPF,EAAoBK,KAAO,IAAM,GACjCL,EAAoBM,QAAUN,EAC9BA,EAAoBO,GAAK,MACzBC,EAAOC,QAAUT,G,yFCNV,MCEMU,EAAmB,CAC9BC,EACAC,EACAC,GAAgB,EAChBC,GAAY,IAEZD,GAAiBF,EAAKI,QAAUH,EAAKG,OACjCJ,EAAKK,OACH,CAACC,EAAUC,EAAWC,IACpBA,EAAQP,EAAKG,OACT,IACKE,KACCH,EACA,CAACF,EAAKO,GAAQD,GACd,CAACA,EAAWN,EAAKO,KAEvB,IAAIF,EAAUC,GACpB,IAEFR,EAAiBE,EAAMD,GAAM,GAAM,GAE5BS,EACXC,GACIC,IACJ,MAAMC,EAASD,EACZE,QACAC,UACAC,UAAUL,GACb,OAAOE,GAAU,EAAID,EAAIP,OAAS,EAAIQ,EAASA,GAMpCI,EAAkBC,GAC7BC,MAAMC,QAAQF,GAAcA,EAAa,CAACA,GCrC/BG,EAAmB,CAACC,EAAuB,KACtD,IAAIC,MAAMD,EAAO,CACfE,IAAK,SAASC,EAAQC,EAAUC,GAC9B,OAAID,KAAYD,EACPA,EAAOC,GAGC,gBAAbA,EAAmC,IAAO,QAC7B,SAAbA,EAA4B,CAACE,MAAO,IAEjC,CACLC,KAAM,UACNC,KAAM,GACNzB,OAAQqB,EAASK,WAAW1B,OAC5BC,OAAS0B,GAAYA,EACrBC,MAAO,GACPF,SAAU,IAAML,EAASK,eCTpBG,EAA8B,CACzCD,MAAO,GACPE,eAAgB,GAChBC,UAAW,GACXC,UAAW,GACXf,MAAOD,IACPiB,OAZwC,CACxCT,KAAM,OACNC,KAAM,GACNxB,OAASiC,GAAQA,GAUjBC,OAAQ,GCdGC,EAAOC,IAA+C,CAE/DpC,OAAQ,UAAgB,UAAC8B,EAAS,MAAEH,KAAUD,IAC5C,MAAO,IACFA,EACHI,UAAW,IAAIA,EAAWO,MAC1BV,MAAO,IAAIA,EAAOS,KAGtBT,MAAO,CAACS,GACRZ,KAAM,CAACY,QACPb,KAAM,QCPGe,EACXC,GAEqB,iBAAdA,GAA0BA,EAAUC,eAAe,YAE/CC,EACXF,GAGAD,EAAsBC,GAAaJ,EAAII,GAAaA,EAEzCG,EAAW,IACnBC,KACgC,CACnCpB,KAAM,QACNC,KAAM,CAACmB,YACP3C,OAAS0B,GACPkB,EAAUD,EAAUjB,KAGXmB,EAAkB,CAC7BC,EACApB,EAAyBE,IAEzBf,MAAMC,QAAQgC,GACVJ,KAAYI,EAAKC,KAAK,KAAKC,IAAIP,IACf,mBAATK,EACPD,EAAgBC,EAAKG,EAAYvB,IAAWA,GAC5Ce,EAAkBK,GC9BjB,SAASI,EAEdxB,GAEA,MAAM,UAACI,KAAcqB,GAAeP,EAAUP,KAAKV,OAAS,GAAID,GAChE,MAAO,IACFyB,EACHrB,UAAW,IAAIA,EAAWO,OAIvB,MAAMe,EAAgB,EAC3BC,UACA7B,UAII8B,OAAOC,OAAOF,EAAS,CAAC7B,SAYjBoB,EAAY,CACvBY,GACCxB,OAAQyB,KAAc/B,GAA2BE,IAElD4B,EAAIxD,OACF,CAAC0B,EAAyBoB,KACxB,MAAMd,EAASa,EAAgBC,EAAMpB,GAC/BgC,EAjBc,CAACnC,IACzB,OAAQA,GACN,IAAK,UACL,IAAK,QACH,OAAO,EACT,QACE,OAAO,IAWgBoC,CAAW3B,EAAOT,MAAQG,EAAQM,OAASA,EAElE,MAAO,IADYA,EAAOhC,OAAO,IAAI0B,EAASM,OAAQ0B,IAC/B1B,OAAQyB,IAEjC,IAAI/B,EAASM,OAAQyB,IClCZG,EAA6B,CACxCrC,KAAM,UACNC,KAAM,GACN,OAAOE,GACL,MAAM,UAACI,EAAS,MAAEH,EAAK,OAAEO,GAAUR,EACnC,MAAO,IACFA,EACHC,MAAOO,EAAS,IAAIP,EAAO,GAAGkC,SAAS3B,IAAWP,EAClDG,UAAW,IAAIA,EAAWO,SAcnByB,GATgB1D,EAC3B,EAAEmB,UAA8B,YAATA,GAQI,EAAEwC,SAAUrC,KACvCA,EAAQQ,OAAS,GANc,CAACR,IAChC,MAAMsC,EAAatC,EAAQC,MNQrBnB,QAAQC,UAAU,GMPxB,OAAQuD,GA1Ba,OA0BJA,GAIKC,CAAkBvC,GAAWkC,EAAU,IC5BlDM,EAAQ,CAACV,EAA8B9B,EAAyBE,KAC3E,MAAM,eAACC,EAAc,MAAEF,GAASiB,EAAUjC,EAAY6C,GAAM9B,GAC5D,MAAO,IAAIG,KAAmBF,GAAOwC,KAAK,KCA/BC,EAAepE,IAA4C,CACtEuB,KAAM,UACNC,KAAMxB,EAAOwB,KACbxB,WAMWqE,EAAqB,CAACC,EAAcC,IAC/CH,EACEhB,EAAc,CACZ5B,KAAM,CAAC8C,QACPjB,QAAU3B,IACR,MAAM,MAACV,EAAK,MAAEW,EAAK,OAAEK,GAAUN,EAC/B,IAAI8C,EAAWF,EACf,GAAIC,EAAI,CACN,MAAO5C,MAAO8C,GAAU7B,EAAUjC,EAAY4D,GAAK,IAC9C7C,EACHC,MAAO,KAET6C,EAAWC,EAAON,KAAK,KAAOG,EAEhC,IAAII,EAAS,EACb,KAAOF,KAAYxD,GACjB0D,IAEAF,EAAW,GAAGF,KAAQI,IAExB,MAAO,IACFhD,EACHM,SACAL,MAAO,IAAIA,EAAO6C,GAClBxD,MAAOD,EAAiB,IACnBC,EACH,CAACsD,GAAO,IACHtC,EACHP,SAAU,IAAM+C,EAChBzE,OAAQyE,EAASzE,eAkClB4E,EAAkB,CAC7BC,EACAC,IAEAT,EACEhB,EAAc,CACZC,QAAU3B,IACR,MAAM,OACJQ,EAAM,UACNJ,EAAS,MACTd,EAAK,UACLe,EAAS,OACTC,EAAM,eACNH,EAAc,MACdF,GACED,EACEoD,EAAelC,EAAUjC,EAAYiE,GAAO,IAC7ClD,EACHQ,OAAQA,EAAS,EACjBH,UAAW,IAAIA,EAAW8C,GAC1B/C,UAAW,GACXH,MAAO,GACPE,eAAgB,KAElB,MAAO,IACFH,EACHG,eAAgB,IAAIA,KAAmBiD,EAAajD,gBACpDF,MAAO,IAAIA,KAAUmD,EAAanD,OAClCG,UAAW,IAAIA,EAAWE,KAAW8C,EAAahD,aAGtDN,KAAM,CAACqD,mBAAkBD,WAwClB3B,EAAevB,IAC1B,IACKA,EAAQV,MACX+C,SAAUrC,ICvJDqD,EAAkBC,GAASA,ECG3BC,EAAgC,CAC3C1D,KAAM,aACNC,KAAM,GACNxB,OAcK,SAEL0B,GAEA,MAAM,UAACI,EAAS,MAAEH,GAASD,EACrBwD,EAZsC,GAAEpD,gBAC9C,MAAMqD,EAA0BC,EAAiBtD,GACjD,OAAOqD,GAA2B,EAC9BrD,EAAUtB,MAAM2E,GAChBrD,GAQwBuD,CAA+B3D,GACrD4D,GC1B0BC,ED0BGL,ECzBnCK,EAAQC,OAAQC,GAAqB,mBAAbA,EAAIlE,OD0BtBmE,EAAc,KAAKJ,EACtBtC,IAAI,EAAExB,MAAOmE,QAASvD,MAAWA,GACjC+B,KAAK,OC7BuB,IAACoB,ED+BhC,MAAO,IACF7D,EACHI,UAAW,IAAIA,EAAWO,MAC1BV,MAAO2D,EAASvF,OACZ,IAAI4B,EJlCW,KIkCK+D,GACpB,IAAI/D,EJnCW,SIQVyD,EAAmBhF,EAC9B,EAAEmB,UAA8B,eAATA,GEPlB,MAAMoE,EAAU,CACrBA,EACAC,GAAY,KACqB,CACjC5F,OAAQkD,EACR3B,KAAM,UACNI,MAAO,CAACmC,EAAe,IAAI8B,EAAY,IAAM,KAAKD,IAAWV,GAC7DzD,KAAM,CAACmE,aCRIE,EAAqB/C,GAChCgD,EAAYhD,GAAME,IAAKZ,GAASuD,EAAQvD,GAAM,IAEnC0D,EAAeC,IAC1B,MAAMC,EAAUD,EAAQE,0BAClBC,EAAWH,EAAQI,2BACzB,MAAO,IACFH,EAAQhD,IAAK2C,GAAYA,EAAQS,UAAUC,MAAM,MAAMlC,KAAK,WAC5D+B,EAASlD,IAAK2C,GAAYA,EAAQS,UAAUC,MAAM,MAAMlC,KAAK,UCAvDX,EAAM,CACjB8C,KACG3E,IAEHA,EAAM4E,MAAOC,GAAyB,mBAATA,GACzB9G,EAAiBmB,MAAM4F,KAAKH,GAAU3E,EAAMoB,KAAK,IAG9CyC,OACE1C,QACU4D,IAAT5D,KACER,EAAsBQ,IAASA,EAAK/C,OAAS,IAElDiD,IAAIP,GACP,CACEC,EAAS,EAAEqB,SAAUrC,KACnBmB,EACEnD,EACEmB,MAAM4F,KAAKH,GAAStD,IAAIP,GACxBd,EACG6D,OAAQgB,QAAyB,IAATA,GACxBxD,IAAKwD,GAAS3D,EAAgB2D,EAAO9E,KAE1CA,KAQCiF,EAAY,CACvBL,KACG3E,KAEH,MAAMiF,EAAUpD,EAAI8C,KAAY3E,IACzBkF,KAAUC,GAAQF,GAClBG,GAAQD,EAAKrG,UACpB,MAAO,IACDoG,GAAwB,YAAfA,EAAMtF,KAAqB,CAACqC,GAAW,MACjDgD,KACEG,GAAsB,eAAdA,EAAKxF,KAAuC,GAAf,CAAC0D,KC1BlC+B,EAAkB,CAC7B1C,EACA2C,IAfqB,EACrBC,EACAD,KAC+B,CAC/BtF,WACkB+E,IAAhBO,EACIN,CAAS,WAAWO,KAAYD,IAChCN,CAAS,WAAWO,IAC1B3F,KAAM,cACNC,KAAM,CAAC0F,WAAUD,eACjBjH,OAAQkD,IAMuBiE,CAAQ9C,EAAmBC,GAAO2C,GAWtDG,EAAkB,EAC7B9C,OACAM,OACAL,SACyC,CACzChD,KAAM,WACNC,KAAM,CAAC8C,OAAMM,OAAML,MACnBvE,OAAQkD,EACRvB,MAAOgF,CAAS,YAAYtC,EAAmBC,EAAMC;EACrDI,EAAgBC,EAAMN,KAAQV,OC7BzB,SAASyD,EAAmBvE,GACjC,MAAO,IAEFA,EACAsD,UACAC,MAAM,MACNrD,IAAKsE,GACJ3B,EACE,iBAAiB2B,EAAKC,OAAO,GAAI,UAAUzE,EAAK0E,mBAsCnD,IAAIC,EArBJ,SACL3E,EACA4E,GAAY,GAEZ,OAAQ5E,EAAK6E,WACX,KAAK,iCACH,OAoEC,SACL7E,GAEA,MAAM8E,EAAa9E,EAAK+E,gBAAgB,GAExC,OAAQD,EAAWD,WACjB,KAAK,4BACH,MAAO,IACF9B,EAAkB/C,MAClBgF,EAAsBF,IAG7B,QACE,OAAOP,EAAmBvE,IAjFnBiF,CAAkBjF,GAC3B,KAAK,iCACH,OAqBC,SACLA,EACA4E,GAAY,GAIZ,MAAMpD,EAAOxB,EAAKkF,UAClB,IAAK1D,EAAM,MAAO,GAClB,MACM2D,EADanF,EAAKoF,gBACElF,IAAI,CAACmF,EAAOhI,KACpC,MAAMmE,EAAO6D,EAAMH,WAAa,IACnBG,EAAMC,UAGnB,OAAOpB,EAAgB1C,EDzDC,CAC1BA,IAC4B,CAC5B/C,KAAM,WACNI,MAAO,CAAC6B,CAAG,MAAMc,EAAK7C,eACtBD,KAAM,CAAC8C,QACPtE,OAAQkD,ICmDuBmF,CAAalI,EAAQ,MAI9CmI,EADkBxF,EAAKyF,gBAE1BvF,IAAKF,GAAS2E,EAAY3E,GAAM,IAChCC,KAAK,GAEFyF,EP7FwB,CAAClE,GAAiB,CAChDmE,EAA4B1D,IACzB,EAAEhB,UAAWhC,gBAChB0G,EAAQ,GAAG1G,EAAUoC,KAAK,QAAQG,KO0FToE,CAAiBpE,GAEpCqE,EAAqB,CAEzBvB,EAAgB,CACd9C,OACAC,GAAImD,EAAYpD,EAAOkE,IACvB5D,KAAM,IAAIqD,KAAWK,MAOzB,OAAOZ,EACHiB,EACAnF,CAAG,GRC4BoB,EQA7B+D,ERCNvE,EACEhB,EAAc,CACZC,QAAU3B,IACR,MAAM,OACJQ,EAAM,UACNJ,EAAS,MACTd,EAAK,UACLe,EAAS,OACTC,EAAM,eACNH,EAAc,MACdF,GACED,EACEkH,EAAmBhG,EAAUjC,EAAYiE,GAAO,IACjDlD,EACHQ,OAAQ,EACRP,MAAO,GACPE,eAAgB,KAElB,MAAO,IACFH,EACHG,eAAgB,IACXA,KAEA+G,EAAiBjH,SACjBiH,EAAiB/G,eFxIT,ME2IbF,QACAG,UAAW8G,EAAiB9G,YAGhCN,KAAM,CAACoD,aQ/BH4D,EAAkBlE,GACpBqB,EAAQ,wCAAwCrB,MRFpB,IAACM,EQ5DxBiE,CAAgB/F,EAAiC4E,GAC1D,KAAK,+BACH,OAoIC,SACL5E,GAEA,MAAMgG,EAAOhG,EAAKiG,qBAElB,OADqBD,EAAKE,kBACNhG,IAAKiG,IACvB,MAAM3E,EAAO2E,EAAYjB,UACnBf,EAAcgC,EAAYC,iBAChC,IAAIC,OAAmCzC,EACvC,GAAIO,EACF,OAAQA,EAAYU,WAClB,KAAK,2BACHwB,EAAQlC,EAAYb,UACpB,MACF,QACE+C,EAAQxD,EACN,iCAAiCsB,EAAYO,eAKrD,OAAOR,EAAgB1C,EAAM6E,KAzJpBC,CAAyBtG,GAClC,KAAK,+BACH,OA+GC,SACLA,GAGA,MAAMuG,EAAavG,EAAKwG,0BAExB,OADwBxG,EAAKyG,kBAE1BvG,IAAKwG,IACJ,MAAMlF,EAAOkF,EAAOxB,UACpB,MR7HmC,EAAC1D,EAAcmF,IACtDrF,EACEhB,EAAc,CACZ5B,KAAM,CAAC8C,OAAMmF,SACbpG,QAAU3B,IACR,MAAM,MAACV,EAAK,OAAEgB,GAAUN,EAClBgI,EAAYxF,EAAMuF,EAAO,IAAI/H,EAASC,MAAO,KACnD,MAAO,IACFD,EACHV,MAAOD,EAAiB,IACnBC,EACH,CAACsD,GAAO,IACHtC,EACHP,SAAU,IAAMiI,EAChB3J,OAAQ2J,EAAU3J,eQ+GnB4J,CAA0BrF,EAAM,YAAY+E,MAAe/E,OAEnEvB,KAAK,GA1HG6G,CAAyB9G,GAClC,KAAK,oCACL,KAAK,qCACH,OA1BC,SAAwBA,GAE7B,MAAO,IAEFA,EACAsD,UACAC,MAAM,MACNrD,IAAKsE,GAAS3B,EAAQ2B,KAmBhBuC,CAAe/G,GACxB,QACE,OAAOuE,EAAmBvE,KA0EzB,SAASgF,EAAsBhF,GACpC,MAAMgH,EAAYhH,EAAKiH,gBACjBC,EAAWlH,EAAKmH,eAChBC,EAAWJ,EAAU1D,UAErB+D,EAAOH,EAAShH,IAAKoH,GAAQA,EAAIhE,WACjCiE,GC/IyBC,EDgJ7BN,EAAShH,IAAKoH,GAAQvE,EAAkBuE,IC/IzC,GAAgBG,UAAUD,IADA,IAAIA,EDkJ/B,MACME,EADcH,EAAgBtK,OAAS,EACX,MAAMsK,EAAgBlG,KAAK,MAAU,GACjEsG,EAAUN,EAAKhG,KAAK,KAE1B,OAAOwC,CAAS,GAAI1E,GAAQA,EAAIiI,IAAaA,IAC3CO,EAAQ1K,OAAS,IAAI0K,EAAY,KAChCD,IAGE,SAASE,EAAY5H,GAC1B,OAAQA,EAAK6E,WACX,KAAK,4BACH,MAAO,GACT,KAAK,wBACL,QAEE,OADa7E,EAEV6H,cACA3H,IAAKF,GAAS2E,EAAY3E,GAAM,IAChCC,KAAK,IEjKP,MAAM6H,EAAiBxI,IAC5B,MAAMyI,GnBHqBC,EmBGD1I,EnBFV,IAAI,EAAA2I,QAAQ,CAC1BC,uBAAuB,EACvBC,sBAAsB,EACtBC,gBAAiB,CACfC,QAAQ,EACRC,OAAO,KAGIC,iBAAiB,UAAWP,IATjB,IAACA,EmBI3B,IACE,OCHG,SAAmBQ,GACxB,IAAKA,EACH,MAAO,GAIT,MACMC,EADWD,EAAOX,cACI3H,IAAI0H,GAAa3H,KAAK,GAClD,OAAOmB,EAAMqH,GDLJC,CAAUX,GACjB,SACA,U","file":"1288.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => [];\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 60326;\nmodule.exports = webpackEmptyContext;","import {Project} from 'ts-morph'\n\nexport const makeTestFile = (fileContents: string) => {\n  const project = new Project({\n    useInMemoryFileSystem: true,\n    addFilesFromTsConfig: false,\n    compilerOptions: {\n      strict: true,\n      noLib: true,\n    },\n  })\n  return project.createSourceFile('main.ts', fileContents)\n}\n","/**\n * Combines two arrays by alternating their indices\n * combineAlternate([a, b, c], [1, 2, 3]) === [a, 1, b, 2, c, 3]\n */\nexport const combineAlternate = <T, Y>(\n  arr1: Array<T>,\n  arr2: Array<Y>,\n  noLengthCheck = false,\n  flipOrder = false,\n): Array<T | Y> =>\n  noLengthCheck || arr1.length >= arr2.length\n    ? arr1.reduce(\n        (combined, arr1value, index) =>\n          index < arr2.length\n            ? [\n                ...combined,\n                ...(flipOrder\n                  ? [arr2[index], arr1value]\n                  : [arr1value, arr2[index]]),\n              ]\n            : [...combined, arr1value],\n        [] as Array<T | Y>,\n      )\n    : combineAlternate(arr2, arr1, true, true)\n\nexport const findLastIndex = <T>(\n  predicate: (value: T, index: number, obj: T[]) => boolean,\n) => (arr: ReadonlyArray<T>) => {\n  const result = arr\n    .slice()\n    .reverse()\n    .findIndex(predicate)\n  return result >= 0 ? arr.length - 1 - result : result\n}\n\nexport const last = <T>(array: Array<T>): T | undefined =>\n  array.slice().reverse()[0]\n\nexport const ensureArray = <T>(maybeArray: T | Array<T>): Array<T> =>\n  Array.isArray(maybeArray) ? maybeArray : [maybeArray]\n","import {ScopeDefinition, TraverseScope} from './types'\n\nexport const createScopeProxy = (scope: TraverseScope = {}) =>\n  new Proxy(scope, {\n    get: function(target, property, receiver): ScopeDefinition {\n      if (property in target) {\n        return target[property as string]!\n      }\n      // workaround for jest:\n      if (property === 'getMockName') return (() => 'Scope') as any\n      if (property === 'mock') return {calls: []} as any\n\n      return {\n        type: 'unknown',\n        data: {},\n        length: property.toString().length,\n        reduce: (context) => context,\n        parts: [],\n        toString: () => property.toString(),\n      }\n    },\n  })\n","import {ASTObject, NoData, TraverseState} from './types'\nimport {createScopeProxy} from './scope-proxy'\n\nexport const astRoot: ASTObject<NoData> = {\n  type: 'root',\n  data: {},\n  reduce: (ctx) => ctx,\n}\n\nexport const emptyContext: TraverseState = {\n  parts: [],\n  partsToExtract: [],\n  processed: [],\n  scopePath: [],\n  scope: createScopeProxy(),\n  parent: astRoot,\n  indent: 0,\n}\n","import {ASTObject} from '../types'\n\nexport const raw = (text : string) : ASTObject<{text : string}> => (\n  {\n    reduce: function reduce({processed, parts, ...context}) {\n      return {\n        ...context,\n        processed: [...processed, this],\n        parts: [...parts, text],\n      }\n    },\n    parts: [text],\n    data: {text},\n    type: 'raw',\n  }\n)","import {ASTExpression, ASTList, ASTObject, TraverseState} from './types'\nimport {raw} from './syntax/raw'\nimport {reduceAST} from './reducers'\nimport {emptyContext} from './context'\nimport {scopeHelper} from './scope'\n\nexport const shouldTreatAsPureText = (\n  textOrAST: ASTObject | string,\n): textOrAST is string =>\n  typeof textOrAST === 'string' || textOrAST.hasOwnProperty('toString')\n\nexport const coerceStringToAST = <T extends ASTExpression>(\n  textOrAST: T,\n): T extends string ? ASTObject<{text: string}> : T =>\n  // @ts-ignore not sure what's going on here, but it works:\n  shouldTreatAsPureText(textOrAST) ? raw(textOrAST) : textOrAST\n\nexport const astGroup = (\n  ...children: ASTList\n): ASTObject<{children: ASTList}> => ({\n  type: 'group',\n  data: {children},\n  reduce: (context: TraverseState): TraverseState =>\n    reduceAST(children, context),\n})\n\nexport const ensureASTObject = (\n  node: ASTExpression,\n  context: TraverseState = emptyContext,\n): ASTObject =>\n  Array.isArray(node)\n    ? astGroup(...node.flat(100).map(coerceStringToAST))\n    : typeof node === 'function'\n    ? ensureASTObject(node(scopeHelper(context)), context)\n    : coerceStringToAST(node)\n","import {ASTList, ASTObject, ASTType, TraverseState, TraverseScope} from './types'\nimport {emptyContext} from './context'\nimport {ensureASTObject} from './context-util'\n\nexport function defaultReduce(\n  this : ASTObject,\n  context : TraverseState,\n) : TraverseState {\n  const {processed, ...nextContext} = reduceAST(this.parts || [], context)\n  return {\n    ...nextContext,\n    processed: [...processed, this],\n  }\n}\n\nexport const defineReducer = <T>({\n  reducer,\n  data,\n} : {\n  reducer : (context : TraverseState) => TraverseState\n  data : T\n}) => Object.assign(reducer, {data})\n\nexport const isSkipType = (type : ASTType) => {\n  switch (type) {\n    case 'enhance':\n    case 'group':\n      return true\n    default:\n      return false\n  }\n}\n\nexport const reduceAST = (\n  ast : ASTList,\n  {parent: astParent, ...context} : TraverseState = emptyContext,\n) : TraverseState =>\n  ast.reduce(\n    (context : TraverseState, node) => {\n      const parent = ensureASTObject(node, context)\n      const parentSkipType = isSkipType(parent.type) ? context.parent : parent\n      const newContext = parent.reduce({...context, parent: parentSkipType})\n      return {...newContext, parent: astParent}\n    },\n    {...context, parent: astParent},\n  )","import {ASTObject, NoData, ScopeContext, TraverseState} from '../types'\nimport {findLastIndex, last} from '../../util/array'\n\nexport const newLine = '\\n'\nexport const semi = '; '\n\n// TODO: should we differentiate start of content flow (terminated by \\n) vs inline content (a; b;)?\n/**\n * marks the start of a new statement in indented content flow\n */\nexport const starter: ASTObject<NoData> = {\n  type: 'starter',\n  data: {},\n  reduce(context): TraverseState {\n    const {processed, parts, indent} = context\n    return {\n      ...context,\n      parts: indent ? [...parts, ''.padStart(indent)] : parts,\n      processed: [...processed, this],\n    }\n  },\n}\n\nexport const lastStarterAt = findLastIndex(\n  ({type}: ASTObject) => type === 'starter',\n)\n\nexport const isBeginningOfLine = (context: TraverseState) => {\n  const token = last(context.parts)\n  return !token || token === newLine\n}\n\nexport const ensureStarter = ({_context: context}: ScopeContext) =>\n  context.indent > 0 && isBeginningOfLine(context) ? starter : ''\n","import {ASTExpression, ASTList, TraverseState, ASTObject, TraverseScope} from './types'\nimport {emptyContext} from './context'\nimport {reduceAST} from './reducers'\nimport {ensureArray} from '../util/array'\n\nexport const print = (ast: ASTExpression | ASTList, context: TraverseState = emptyContext) => {\n  const {partsToExtract, parts} = reduceAST(ensureArray(ast), context)\n  return [...partsToExtract, ...parts].join('')\n}\n","import {ASTExpression, ASTObject, DefinedReducer, ScopeContext, TraverseState} from './types'\nimport {ensureArray} from '../util/array'\nimport {defineReducer, reduceAST} from './reducers'\nimport {newLine} from './syntax/starter'\nimport {createScopeProxy} from './scope-proxy'\nimport {print} from './writer'\n\nexport const asObject = <T>(reduce: DefinedReducer<T>): ASTObject<T> => ({\n  type: 'enhance',\n  data: reduce.data,\n  reduce,\n})\n\n/**\n * adds a variable to scope and prints its name\n */\nexport const addToScopeAndWrite = (name: string, as?: ASTExpression) =>\n  asObject(\n    defineReducer({\n      data: {name},\n      reducer: (context: TraverseState): TraverseState => {\n        const {scope, parts, parent} = context\n        let safeName = name\n        if (as) {\n          const {parts: asName} = reduceAST(ensureArray(as), {\n            ...context,\n            parts: [],\n          })\n          safeName = asName.join('') || name\n        }\n        let append = 0\n        while (safeName in scope) {\n          append++\n          // we need to rename this variable\n          safeName = `${name}_${append}`\n        }\n        return {\n          ...context,\n          parent,\n          parts: [...parts, safeName],\n          scope: createScopeProxy({\n            ...scope,\n            [name]: {\n              ...parent,\n              toString: () => safeName,\n              length: safeName.length,\n            },\n          }),\n        }\n      },\n    }),\n  )\n\nexport const addToScopeAndReplaceUsage = (name: string, usage: ASTExpression) =>\n  asObject(\n    defineReducer({\n      data: {name, usage},\n      reducer: (context: TraverseState): TraverseState => {\n        const {scope, parent} = context\n        const usageText = print(usage, {...context, parts: []})\n        return {\n          ...context,\n          scope: createScopeProxy({\n            ...scope,\n            [name]: {\n              ...parent,\n              toString: () => usageText,\n              length: usageText.length,\n            },\n          }),\n        }\n      },\n    })\n  )\n\n/**\n * in scopes { ... } and sub-shells ( ... ) we \"fork\" context\n * i.e. ignore its result down the line\n */\nexport const inIsolatedScope = (\n  body: ASTExpression,\n  scopeDescription: string,\n) =>\n  asObject(\n    defineReducer({\n      reducer: (context) => {\n        const {\n          indent,\n          processed,\n          scope,\n          scopePath,\n          parent,\n          partsToExtract,\n          parts,\n        } = context\n        const innerContext = reduceAST(ensureArray(body), {\n          ...context,\n          indent: indent + 2,\n          scopePath: [...scopePath, scopeDescription],\n          processed: [],\n          parts: [],\n          partsToExtract: [],\n        })\n        return {\n          ...context,\n          partsToExtract: [...partsToExtract, ...innerContext.partsToExtract],\n          parts: [...parts, ...innerContext.parts],\n          processed: [...processed, parent, ...innerContext.processed],\n        }\n      },\n      data: {scopeDescription, body},\n    }),\n  )\n\nexport const extractedToRootScope = (body: ASTExpression) =>\n  asObject(\n    defineReducer({\n      reducer: (context) => {\n        const {\n          indent,\n          processed,\n          scope,\n          scopePath,\n          parent,\n          partsToExtract,\n          parts,\n        } = context\n        const extractedContext = reduceAST(ensureArray(body), {\n          ...context,\n          indent: 0,\n          parts: [],\n          partsToExtract: [],\n        })\n        return {\n          ...context,\n          partsToExtract: [\n            ...partsToExtract,\n            // we move normal parts to extracted ones:\n            ...extractedContext.parts,\n            ...extractedContext.partsToExtract,\n            newLine,\n          ],\n          parts,\n          processed: extractedContext.processed,\n        }\n      },\n      data: {body},\n    }),\n  )\n\nexport const scopeHelper = (context: TraverseState) =>\n  ({\n    ...context.scope,\n    _context: context,\n  } as ScopeContext)\n\n\n","import {ScopeContext} from '../writer/types'\n\nexport const passthrough = <T>(t: T) => t\n\nexport const getNameGenerator = (name: string) => <T>(\n  wrapper: (t: string) => T = passthrough as (t: string) => T,\n) => ({_context: {scopePath}}: ScopeContext) =>\n  wrapper(`${scopePath.join('.')}.${name}`)\n","import {ASTObject, NoData, TraverseState} from '../types'\nimport {newLine} from './starter'\nimport {findLastIndex} from '../../util/array'\nimport {getInlineComments} from './comment-util'\n\nexport const terminator: ASTObject<NoData> = {\n  type: 'terminator',\n  data: {},\n  reduce: terminatorReduce,\n}\n\nexport const lastTerminatorAt = findLastIndex(\n  ({type}: ASTObject) => type === 'terminator',\n)\n\nexport const contentSincePreviousTerminator = ({processed}: TraverseState) => {\n  const previousTerminatorIndex = lastTerminatorAt(processed)\n  return previousTerminatorIndex >= 0\n    ? processed.slice(previousTerminatorIndex)\n    : processed\n}\n\nexport function terminatorReduce(\n  this: ASTObject<NoData>,\n  context: TraverseState,\n): TraverseState {\n  const {processed, parts} = context\n  const sinceLastTerminator = contentSincePreviousTerminator(context)\n  const comments = getInlineComments(sinceLastTerminator)\n  const commentText = `# ${comments\n    .map(({data: {comment: text}}) => text)\n    .join(' | ')}`\n\n  return {\n    ...context,\n    processed: [...processed, this],\n    parts: comments.length\n      ? [...parts, newLine, commentText]\n      : [...parts, newLine],\n  }\n}\n","import {ASTObject, CommentData} from '../types'\n\nexport const getInlineComments = (objects : Array<ASTObject>) =>\n  objects.filter((obj) => obj.type === 'comment-inline') as Array<ASTObject<CommentData>>","import {ASTObject} from '../types'\nimport {ensureStarter} from './starter'\nimport {terminator} from './terminator'\nimport {defaultReduce} from '../reducers'\n\nexport const comment = (\n  comment: string,\n  withSpace = true,\n): ASTObject<{comment: string}> => ({\n  reduce: defaultReduce,\n  type: 'comment',\n  parts: [ensureStarter, `#${withSpace ? ' ' : ''}${comment}`, terminator],\n  data: {comment},\n})\n\n\n","import * as AST from 'ts-morph'\nimport {comment} from '../writer/syntax/comment'\nimport {ASTObject} from '../writer/types'\n\nexport const getCommentObjects = (node: AST.Node) =>\n  getComments(node).map((text) => comment(text, false))\n\nexport const getComments = (astNode: AST.Node) => {\n  const leading = astNode.getLeadingCommentRanges()\n  const trailing = astNode.getTrailingCommentRanges()\n  return [\n    ...leading.map((comment) => comment.getText().split('\\n').join('\\n#')),\n    ...trailing.map((comment) => comment.getText().split('\\n').join('\\n#')),\n  ]\n}\n","import {ASTExpression, ASTObject} from './types'\nimport {starter} from './syntax/starter'\nimport {terminator} from './syntax/terminator'\nimport {combineAlternate} from '../util/array'\nimport {coerceStringToAST, shouldTreatAsPureText} from './context-util'\nimport {astGroup} from './context-util'\nimport {ensureASTObject} from './context-util'\nimport {TraverseScope, TraverseState} from './types'\n\n/**\n * Template string for creating AST from nodes/strings and functions\n */\nexport const ast = (\n  strings: TemplateStringsArray,\n  ...parts: Array<ASTExpression | undefined>\n): Array<ASTObject> =>\n  parts.every((part) => typeof part !== 'function')\n    ? combineAlternate(Array.from(strings), parts.flat(1) as Array<\n        string | ASTObject\n      >)\n        .filter(\n          (node) =>\n            node !== undefined &&\n            (!shouldTreatAsPureText(node) || node.length > 0),\n        )\n        .map(coerceStringToAST)\n    : [\n        astGroup(({_context: context}) =>\n          ensureASTObject(\n            combineAlternate(\n              Array.from(strings).map(coerceStringToAST),\n              parts\n                .filter((part) => typeof part !== 'undefined')\n                .map((part) => ensureASTObject(part!, context)),\n            ),\n            context,\n          ),\n        ),\n      ]\n\n/**\n * a template string literal function for writing complete expressions\n */\nexport const statement = (\n  strings: TemplateStringsArray,\n  ...parts: Array<ASTExpression | undefined>\n): Array<ASTObject> => {\n  const applied = ast(strings, ...parts)\n  const [first, ...rest] = applied\n  const [last] = rest.reverse()\n  return [\n    ...(first && first.type !== 'starter' ? [starter] : []),\n    ...applied,\n    ...(!last || last.type !== 'terminator' ? [terminator] : []),\n  ]\n}\n","import {\n  ASTExpression,\n  ASTObject,\n  DeclarationData,\n  FunctionAST,\n  VariableData,\n  TraverseScope,\n  TraverseState,\n} from '../types'\nimport {defaultReduce} from '../reducers'\nimport {starter} from './starter'\nimport {ast, statement} from '../statement'\nimport {addToScopeAndWrite, inIsolatedScope} from '../scope'\n\nexport const declare = (\n  variable: ASTExpression,\n  initializer?: ASTExpression,\n): ASTObject<DeclarationData> => ({\n  parts:\n    initializer !== undefined\n      ? statement`declare ${variable}=${initializer}`\n      : statement`declare ${variable}`,\n  type: 'declaration',\n  data: {variable, initializer},\n  reduce: defaultReduce,\n})\n\nexport const declareVariable = (\n  name: string,\n  initializer?: ASTExpression,\n): ASTObject<DeclarationData> => declare(addToScopeAndWrite(name), initializer)\n\nexport const referenceVar = (\n  name: string | number,\n): ASTObject<VariableData> => ({\n  type: 'variable',\n  parts: [ast`\\${${name.toString()}}`],\n  data: {name},\n  reduce: defaultReduce,\n})\n\nexport const declareFunction = ({\n  name,\n  body,\n  as,\n}: FunctionAST): ASTObject<FunctionAST> => ({\n  type: 'function',\n  data: {name, body, as},\n  reduce: defaultReduce,\n  parts: statement`function ${addToScopeAndWrite(name, as)} {\n${inIsolatedScope(body, name)}${starter}}`,\n})\n\n/* WIP:\nconst functionCall = ({\n  name,\n  args,\n  comments,\n}) => ({\n  type: 'call',\n  data: {name, args, comments},\n  reduce: defaultReduce,\n  parts: statement`${(ctx) => ctx[name] || name} ${args}${comments && ` # ${comments}`}`\n})\n*/\n","import * as AST from 'ts-morph'\nimport {\n  addToScopeAndReplaceUsage,\n  addToScopeAndWrite,\n  extractedToRootScope,\n} from './writer/scope'\nimport {getNameGenerator} from './util/visitor'\nimport {flatmapSimple} from './util/flatmap-simple'\nimport {getCommentObjects, getComments} from './util/ast'\nimport {ASTExpression, ASTObject} from './writer/types'\nimport {\n  declareFunction,\n  declareVariable,\n  referenceVar,\n} from './writer/syntax/parts'\nimport {comment} from './writer/syntax/comment'\nimport {ast, statement} from './writer/statement'\nimport {newLine} from './writer/syntax/starter'\n\nexport type VisitorReturn = Array<ASTObject>\n\nexport function unsupportedVisitor(node: AST.Node): VisitorReturn {\n  return [\n    // ...getCommentObjects(node),\n    ...node\n      .getText()\n      .split('\\n')\n      .map((line) =>\n        comment(\n          `<unsupported> ${line.padEnd(40, ' ')} # ${node.getKindName()}`,\n        ),\n      ),\n  ]\n}\n\nexport function commentVisitor(node: AST.Node): VisitorReturn {\n  // return [...getCommentObjects(node)]\n  return [\n    // ...getCommentObjects(node),\n    ...node\n      .getText()\n      .split('\\n')\n      .map((line) => comment(line)),\n  ]\n}\n\nexport function genericNodeVisitor(\n  node: AST.Node,\n  rootScope = true,\n): VisitorReturn {\n  switch (node.getKind()) {\n    case AST.SyntaxKind.ExpressionStatement:\n      return expressionVisitor(node as AST.Node<AST.ts.ExpressionStatement>)\n    case AST.SyntaxKind.FunctionDeclaration:\n      return functionVisitor(node as AST.FunctionDeclaration, rootScope)\n    case AST.SyntaxKind.VariableStatement:\n      return variableStatementVisitor(node as AST.VariableStatement)\n    case AST.SyntaxKind.ImportDeclaration:\n      return importDeclarationVisitor(node as AST.ImportDeclaration)\n    case AST.SyntaxKind.MultiLineCommentTrivia:\n    case AST.SyntaxKind.SingleLineCommentTrivia:\n      return commentVisitor(node)\n    default:\n      return unsupportedVisitor(node)\n  }\n}\n\nexport let nodeVisitor = genericNodeVisitor\n\nexport const setNodeVisitor = (\n  visitor: (node: AST.Node, rootScope?: boolean) => VisitorReturn,\n) => {\n  nodeVisitor = visitor\n}\n\nexport function functionVisitor(\n  node: AST.FunctionDeclaration,\n  rootScope = true,\n): VisitorReturn {\n  // const body = node.getBody() as AST.Block | undefined\n  // if (!body) return empty\n  const name = node.getName()\n  if (!name) return []\n  const paramNodes = node.getParameters()\n  const params = paramNodes.map((param, index) => {\n    const name = param.getName() || '_'\n    const type = param.getType()\n    // console.log(type.getText())\n\n    return declareVariable(name, referenceVar(index + 1))\n    // return `local ${name}=\"$${index+1}\"`\n  })\n  const innerStatements = node.getStatements()\n  const transformedStatements = innerStatements\n    .map((node) => nodeVisitor(node, false))\n    .flat(1)\n\n  const getNameFromScope = getNameGenerator(name)\n\n  const functionStatements = [\n    // ...getCommentObjects(node),\n    declareFunction({\n      name,\n      as: rootScope ? name : getNameFromScope(),\n      body: [...params, ...transformedStatements],\n    }),\n    // `${name}() {`,\n    // ...transformedDeclaration.statements.map(s => `  ${s}`),\n    // '}',\n  ]\n\n  return rootScope\n    ? functionStatements\n    : ast`${extractedToRootScope(\n        functionStatements,\n      )}${getNameFromScope((name) =>\n        comment(`function declaration extracted, see: ${name}`),\n      )}`\n}\n\nexport function expressionVisitor(\n  node: AST.Node<AST.ts.ExpressionStatement>,\n): VisitorReturn {\n  const expression = node.getChildAtIndex(0)!\n  // console.log(expression)\n  switch (expression.getKind()) {\n    case AST.SyntaxKind.CallExpression:\n      return [\n        ...getCommentObjects(node),\n        ...callExpressionVisitor(expression as AST.CallExpression),\n      ]\n    // const callExpr = expression as AST.CallExpression\n    default:\n      return unsupportedVisitor(node)\n  }\n}\n\nexport function callExpressionVisitor(node: AST.CallExpression): VisitorReturn {\n  const identNode = node.getExpression()\n  const argNodes = node.getArguments()\n  const callable = identNode.getText()\n  // TODO: map args depending on their type, i.e. passthrough StringLiteral\n  const args = argNodes.map((arg) => arg.getText())\n  const argCommentsList = flatmapSimple(\n    argNodes.map((arg) => getCommentObjects(arg)),\n  )\n  const hasComments = argCommentsList.length > 0\n  const argComments = hasComments ? ` # ${argCommentsList.join(', ')}` : ''\n  const argsRaw = args.join(' ')\n  // TODO: functionCall({})\n  return statement`${(ctx) => ctx[callable] || callable}${\n    argsRaw.length ? ` ${argsRaw}` : ''\n  }${argComments}`\n}\n\nexport function fileVisitor(node: AST.Node): VisitorReturn {\n  switch (node.getKind()) {\n    case AST.SyntaxKind.EndOfFileToken:\n      return []\n    case AST.SyntaxKind.SyntaxList:\n    default:\n      const list = node as AST.SyntaxList\n      return list\n        .getChildren()\n        .map((node) => nodeVisitor(node, true))\n        .flat(1)\n  }\n}\n\nexport function importDeclarationVisitor(\n  node: AST.ImportDeclaration,\n): VisitorReturn {\n  // return unsupportedVisitor(node)\n  const importFrom = node.getModuleSpecifierValue()\n  const importedMembers = node.getNamedImports()\n  return importedMembers\n    .map((member) => {\n      const name = member.getName()\n      return addToScopeAndReplaceUsage(name, `@module \"${importFrom}\" ${name}`)\n    })\n    .flat(1)\n\n  // return importedMembers.map((member) => {\n  //   const name = member.getName()\n  //   return statement`${addToScopeAndReplaceUsage(name, `@module \"${importFrom}\" ${name}`)}`\n  // }).flat(1)\n}\n\nexport function variableStatementVisitor(\n  node: AST.VariableStatement,\n): VisitorReturn {\n  const list = node.getDeclarationList()\n  const declarations = list.getDeclarations()\n  return declarations.map((declaration) => {\n    const name = declaration.getName()\n    const initializer = declaration.getInitializer()\n    let value: ASTExpression | undefined = undefined\n    if (initializer) {\n      switch (initializer.getKind()) {\n        case AST.SyntaxKind.StringLiteral:\n          value = initializer.getText()\n          break\n        default:\n          value = comment(\n            `Unsupported initializer type: ${initializer.getKindName()}`,\n          )\n          break\n      }\n    }\n    return declareVariable(name, value)\n  })\n}\n\n// AST\n","export const flatmapSimple = <T>(nestedArray: Array<Array<T>>): Array<T> =>\n  ([] as Array<T>).concat(...nestedArray)\n","import './index.css'\nimport {makeTestFile} from '../src/util/test-util'\nimport {transpile} from '../src/transpile'\n\nexport const transpileText = (text: string) => {\n  const file = makeTestFile(text)\n  try {\n    return transpile(file)\n  } catch {\n    return undefined\n  }\n}\n","import {SourceFile} from 'ts-morph'\nimport {fileVisitor} from './visitors'\nimport {print} from './writer/writer'\n\nexport function transpile(source: SourceFile | undefined) {\n  if (!source) {\n    return ''\n  }\n  // ordered statements in the file\n  // function call is a statement, function definition is a statement, etc.\n  const children = source.getChildren()\n  const statements = children.map(fileVisitor).flat(1)\n  return print(statements)\n}\n"],"sourceRoot":""}