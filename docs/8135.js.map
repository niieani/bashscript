{"version":3,"sources":["webpack://bashscript/./src/util/array.ts","webpack://bashscript/./src/ast/bash-ast.ts","webpack://bashscript/./src/scope.ts","webpack://bashscript/./src/visitors.ts","webpack://bashscript/./src/transpile.ts","webpack://bashscript/./repl/transpile.ts","webpack://bashscript/./node_modules/typescript/lib|sync"],"names":["combineAlternate","arr1","arr2","noLengthCheck","flipOrder","length","reduce","combined","arr1value","index","DECLARE_FLAGS","STRING","INTEGER","ARRAY","ASSOCIATIVE_ARRAY","writeParameter","identifier","valueType","flags","join","write","SH_ESCAPED_SLASH","String","fromCodePoint","WRITERS","ArrayLiteral","elements","map","element","AssignmentExpression","operator","value","output","CallExpression","callee","args","argument","CallReference","expression","quoted","File","statements","statement","FunctionDeclaration","name","parameters","indentation","innerIndentation","spacing","repeat","parameter","FunctionIdentifier","Parameter","StringLiteral","writeStringLiteral","style","type","replace","includes","match","NumericLiteral","TemplateElement","TemplateLiteral","expressions","quasis","expressionOutput","quasisOutput","VariableDeclaration","initializer","VariableIdentifier","VariableReference","bang","UnsupportedSyntax","node","writer","getChildrenRecursively","skip","Object","values","flatMap","Array","isArray","filter","getChildren","child","grandChild","makeCallExpression","makeBashSafeVariableName","Scope","parentScope","byTSName","Map","byBashName","anonymousId","this","isRoot","path","key","skipRoot","keyType","undefined","get","has","list","warnings","forEach","item","previousItem","push","message","lookupKind","bashName","set","SyntaxKind","fromEntries","entries","result","translateTsAstToBashAst","tsNodes","scope","visitorOverrides","scopeInfo","resultResolvers","merged","processTsNode","populate","errors","nodes","VISITORS","SourceFile","sourceFile","ImportDeclaration","importDeclaration","importClause","moduleSpecifier","importedFrom","text","namedBindings","kind","importSpecifier","propertyName","elementBeingImported","scopeName","ExpressionStatement","expressionStatement","ReturnStatement","callExpression","arguments","lookup","processedArgs","literal","VariableStatement","declarationList","declarations","declaration","nameIdentifier","initializerNodes","initializerErrors","n","bashInitializer","ArrowFunction","arrowFn","getNextAnonymousId","functionDeclaration","body","originalFnName","bashFnName","makeBashSafeFunctionName","fnScope","bashParams","bashStatements","uniqByName","uniqBy","nestedFunctionDeclarations","bashStatementNodes","subFnBashName","subFnActualBashName","children","referencedScopedIdentifiers","Identifier","syntaxKind","visitor","unimplementedVisitor","transpileCode","code","fileName","bashAst","console","log","transpile","transpileText","webpackEmptyContext","req","e","Error","keys","resolve","id","module","exports"],"mappings":"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","file":"8135.js","sourcesContent":["/**\n * Combines two arrays by alternating their indices\n * combineAlternate([a, b, c], [1, 2, 3]) === [a, 1, b, 2, c, 3]\n */\nexport const combineAlternate = <T, Y>(\n  arr1: Array<T>,\n  arr2: Array<Y>,\n  noLengthCheck = false,\n  flipOrder = false,\n): Array<T | Y> =>\n  noLengthCheck || arr1.length >= arr2.length\n    ? arr1.reduce(\n        (combined, arr1value, index) =>\n          index < arr2.length\n            ? [\n                ...combined,\n                ...(flipOrder\n                  ? [arr2[index], arr1value]\n                  : [arr1value, arr2[index]]),\n              ]\n            : [...combined, arr1value],\n        [] as Array<T | Y>,\n      )\n    : combineAlternate(arr2, arr1, true, true)\n\nexport const findLastIndex = <T>(\n  predicate: (value: T, index: number, obj: T[]) => boolean,\n) => (arr: ReadonlyArray<T>) => {\n  const result = arr.slice().reverse().findIndex(predicate)\n  return result >= 0 ? arr.length - 1 - result : result\n}\n\nexport const last = <T>(array: Array<T>): T | undefined =>\n  array.slice().reverse()[0]\n\nexport const ensureArray = <T>(maybeArray: T | Array<T>): Array<T> =>\n  Array.isArray(maybeArray) ? maybeArray : [maybeArray]\n","import {combineAlternate} from '../util/array'\n\nexport interface AstNode<Type extends string> {\n  type: Type\n}\n\nexport type AssignmentValue =\n  | undefined\n  | StringLiteral\n  | NumericLiteral\n  | ArrayLiteral\n  | TemplateLiteral\n  | CallReference\n\n/**\n * @example\n * ```shell\n * declare name=\"${1:-default}\"\n * ```\n */\nexport interface Parameter extends AstNode<'Parameter'> {\n  identifier: VariableIdentifier\n  valueType?: 'STRING' | 'INTEGER' | 'ARRAY' | 'ASSOCIATIVE_ARRAY'\n  // TODO: default value\n  // TODO: valueType: 'STRING' | 'NUMBER' | 'ARRAY'\n  // although maybe for readonly it makes sense?\n}\n\nconst DECLARE_FLAGS = {\n  STRING: [],\n  INTEGER: ['i'],\n  ARRAY: ['a'],\n  ASSOCIATIVE_ARRAY: ['A'],\n}\n\nfunction writeParameter(\n  {identifier, valueType = 'STRING'}: Parameter,\n  index: number,\n): string {\n  const flags = DECLARE_FLAGS[valueType]\n  const flagArg = flags.length > 0 ? `-${flags.join('')} ` : ''\n  return `local ${flagArg}${write(identifier)}=\"\\${${index}}\"`\n  // if (default) {\n  //   output += `=${write(initializer)}`\n  // }\n}\n\n/**\n * @example\n * ```shell\n * \"something ${variable} $(command arg) ${variable:-default}\"\n * ```\n */\nexport interface TemplateLiteral extends AstNode<'TemplateLiteral'> {\n  expressions: Array<VariableReference | CallReference> // TODO: add ExpressionLiteral like $(( 1 + 2 ))\n  quasis: Array<TemplateElement>\n}\n\nfunction writeTemplateLiteral({expressions, quasis}: TemplateLiteral): string {\n  const expressionOutput = expressions.map((expression) =>\n    write({...expression, quoted: false}),\n  )\n  const quasisOutput = quasis.map((quasis) => write(quasis))\n  return `\"${combineAlternate(quasisOutput, expressionOutput).join('')}\"`\n}\n\nexport interface TemplateElement extends AstNode<'TemplateElement'> {\n  value: string\n}\n\nfunction writeTemplateElement({value}: TemplateElement): string {\n  return value\n}\n\nexport interface StringLiteral extends AstNode<'StringLiteral'> {\n  style?: 'UNQUOTED' | 'SINGLE_QUOTED' | 'DOUBLE_QUOTED' | 'HEREDOC'\n  value: string\n}\n\nconst SH_ESCAPED_SLASH = String.fromCodePoint(92) + \"'\"\n\nfunction writeStringLiteral({style, value, type}: StringLiteral): string {\n  switch (style) {\n    // TODO: add support for all types\n    case 'SINGLE_QUOTED':\n      return `'${value.replace(/'/g, `'${SH_ESCAPED_SLASH}'`)}'`\n    case 'UNQUOTED':\n      return value.replace(/[^a-zA-Z0-9-_./]/g, (value) => `\\\\${value}`)\n    default: {\n      if (value.includes('\\n'))\n        return writeStringLiteral({type, value, style: 'HEREDOC'})\n      if (value.match(/[^a-zA-Z0-9-_./]/)) {\n        if (value.includes(\"'\"))\n          return writeStringLiteral({type, value, style: 'DOUBLE_QUOTED'})\n        else return writeStringLiteral({type, value, style: 'SINGLE_QUOTED'})\n      } else {\n        return writeStringLiteral({type, value, style: 'UNQUOTED'})\n      }\n    }\n  }\n}\n\nexport interface NumericLiteral extends AstNode<'NumericLiteral'> {\n  value: string\n}\n\nfunction writeNumericLiteral({value}: NumericLiteral): string {\n  return value\n}\n\n/**\n * @example\n * ```shell\n * (\"value\" \"another value\")\n * ```\n */\nexport interface ArrayLiteral extends AstNode<'ArrayLiteral'> {\n  elements: Array<StringLiteral | TemplateLiteral>\n}\n\nfunction writeArrayLiteral({elements}: ArrayLiteral): string {\n  return `(${elements.map((element) => write(element)).join(' ')})`\n}\n\n/**\n * The reference to a variable\n * @example ${name}\n * @example ${1}\n */\nexport interface VariableReference extends AstNode<'VariableReference'> {\n  identifier: VariableIdentifier\n  // evaluates the variable named like the variable contents: ${!variable} === ${other}, where variable='other'\n  bang?: boolean\n  // ensures the variable must be quoted and will not expand, i.e. \"${name}\"\n  quoted?: boolean\n  // TODO: modifiers, fallback value, etc.\n}\n\nfunction writeVariableReference({\n  identifier,\n  bang,\n  quoted,\n}: VariableReference): string {\n  const value = `\\${${bang ? '!' : ''}${write(identifier)}}`\n  return quoted ? `\"${value}\"` : value\n}\n\n/**\n * The reference to a subshell evaluation\n * @example $(ls)\n */\nexport interface CallReference extends AstNode<'CallReference'> {\n  expression: CallExpression\n  quoted?: boolean\n}\n\nfunction writeCallReference({expression, quoted}: CallReference): string {\n  const value = `\\$(${write(expression)})`\n  return quoted ? `\"${value}\"` : value\n}\n\nexport type CallExpressionArgument =\n  | StringLiteral\n  | TemplateLiteral\n  | VariableReference\n  | CallReference\n\n/**\n * @example\n * ```shell\n * command some-arg \"another arg\" \"$(subcommand arg2)\"\n * ```\n */\nexport interface CallExpression extends AstNode<'CallExpression'> {\n  callee: FunctionIdentifier\n  args: Array<CallExpressionArgument>\n}\n\nfunction writeCallExpression({callee, args}: CallExpression): string {\n  let output = write(callee)\n  if (args.length > 0) {\n    output += ' ' + args.map((argument) => write(argument)).join(' ')\n  }\n  return output\n}\n\n/**\n * Variable name\n */\nexport interface VariableIdentifier extends AstNode<'VariableIdentifier'> {\n  name: string\n}\n\nfunction writeVariableIdentifier({name}: VariableIdentifier): string {\n  return name\n}\n\n/**\n * The reference to a function\n */\nexport interface FunctionIdentifier extends AstNode<'FunctionIdentifier'> {\n  name: string\n}\n\nfunction writeFunctionIdentifier({name}: FunctionIdentifier): string {\n  return name\n}\n\n/**\n * @example\n * ```shell\n * name=value\n * ```\n */\nexport interface AssignmentExpression extends AstNode<'AssignmentExpression'> {\n  identifier: VariableIdentifier\n  value: AssignmentValue\n  operator: '=' | '+='\n}\n\nfunction writeAssignmentExpression({\n  identifier,\n  operator,\n  value,\n}: AssignmentExpression): string {\n  let output = `${write(identifier)}${operator}`\n  if (value) {\n    output += write(value)\n  }\n  return output\n}\n\n/**\n * @example\n * ```shell\n * declare name=value\n * ```\n */\nexport interface VariableDeclaration extends AstNode<'VariableDeclaration'> {\n  identifier: VariableIdentifier\n  initializer: AssignmentValue\n  // TODO: consider valueType: 'STRING' | 'NUMBER' | 'ARRAY'; probably not needed, we can infer from initializer type\n}\n\nfunction writeVariableDeclaration({\n  identifier,\n  initializer,\n}: VariableDeclaration): string {\n  let output = 'declare '\n  // TODO: this is for an integer, not any number; we need to reconsider how we are storing numbers\n  if (initializer?.type === 'NumericLiteral') output += '-i '\n  if (initializer?.type === 'ArrayLiteral') output += '-a '\n  output += write(identifier)\n  if (initializer) {\n    output += `=${write(initializer)}`\n  }\n  return output\n}\n\n// expressions legal inside of a function body:\nexport type FunctionBodyExpression = VariableDeclaration | CallExpression\n\n/**\n * @example\n * ```shell\n * function name() {\n *   local param=\"$1\"\n *   true\n * }\n * ```\n */\nexport interface FunctionDeclaration extends AstNode<'FunctionDeclaration'> {\n  name: FunctionIdentifier\n  /** parameters are not a native bash feature, but we want this in the writer for ease of use */\n  parameters: Array<Parameter>\n  statements: Array<FunctionBodyExpression>\n}\n\nfunction writeFunctionDeclaration(\n  {name, parameters, statements}: FunctionDeclaration,\n  indentation = 0,\n): string {\n  let output = `function ${write(name)} {\\n`\n\n  const innerIndentation = indentation + 2\n  const spacing = ' '.repeat(innerIndentation)\n\n  if (parameters.length > 0) {\n    output += parameters\n      .map((parameter, index) => spacing + writeParameter(parameter, index))\n      .join('\\n')\n\n    output += '\\n'\n  }\n\n  output += statements\n    .map((statement) => spacing + write(statement, innerIndentation))\n    .join('\\n')\n\n  output += '\\n}'\n\n  return output\n}\n\n/**\n * The reference to a function\n */\nexport interface UnsupportedSyntax extends AstNode<'UnsupportedSyntax'> {\n  message: string\n}\n\nfunction writeUnsupportedSyntax(node: UnsupportedSyntax): string {\n  return ''\n}\n\nexport type FileExpression = FunctionBodyExpression | FunctionDeclaration\n\nexport interface BashFile extends AstNode<'File'> {\n  statements: Array<FileExpression>\n}\n\nfunction writeFile({statements}: BashFile): string {\n  return statements.map((statement) => write(statement)).join('\\n')\n}\n\n///////////\n\nexport type NodeWriters = typeof WRITERS\nexport type NodeTypes = keyof NodeWriters\nexport type AllNodeWriters = {\n  [K in keyof NodeWriters]: NodeWriters[K] extends typeof unimplementedWriter\n    ? (node: AstNode<K>) => string\n    : NodeWriters[K]\n}\n\nexport type ImplementedNodeTypes = {\n  [K in keyof NodeWriters]: NodeWriters[K] extends typeof unimplementedWriter\n    ? never\n    : K\n}[keyof NodeWriters]\n\nexport type AllBashASTNodes = Parameters<NodeWriters[ImplementedNodeTypes]>[0]\n\nconst WRITERS = {\n  ArrayLiteral: writeArrayLiteral,\n  AssignmentExpression: writeAssignmentExpression,\n  CallExpression: writeCallExpression,\n  CallReference: writeCallReference,\n  File: writeFile,\n  FunctionDeclaration: writeFunctionDeclaration,\n  FunctionIdentifier: writeFunctionIdentifier,\n  Parameter: writeParameter,\n  StringLiteral: writeStringLiteral,\n  NumericLiteral: writeNumericLiteral,\n  TemplateElement: writeTemplateElement,\n  TemplateLiteral: writeTemplateLiteral,\n  VariableDeclaration: writeVariableDeclaration,\n  VariableIdentifier: writeVariableIdentifier,\n  VariableReference: writeVariableReference,\n  UnsupportedSyntax: writeUnsupportedSyntax,\n}\n\nfunction unimplementedWriter({type}: AstNode<string>): never {\n  throw new Error(`Writer for ${type} is not supported yet`)\n}\n\nexport function write(node: AllBashASTNodes, indentation = 0) {\n  const writer = WRITERS[node.type] as (\n    node: AstNode<string>,\n    indentation?: number,\n  ) => string\n  return writer(node, indentation)\n}\n\nexport function getChildren(node: AllBashASTNodes) {\n  const values = Object.values(node)\n  const children: AllBashASTNodes[] = values\n    .flatMap((value) => (Array.isArray(value) ? value : [value]))\n    .filter((value) => typeof value === 'object' && 'type' in value)\n  return children\n}\n\nexport function getChildrenRecursively(\n  node: AllBashASTNodes,\n  skip: AllBashASTNodes['type'][] = [],\n): AllBashASTNodes[] {\n  return getChildren(node).flatMap((child) => [\n    child,\n    ...getChildrenRecursively(child, skip).filter(\n      (grandChild) => !skip.includes(grandChild.type),\n    ),\n  ])\n}\n\n// NOTE: maybe it could be using 'typescript' directly as a TS plugin?\n// then we could also add red squiggly marks for not implemented features, by node type in a given position!\n// https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\n\nexport const makeCallExpression = (\n  callee: string,\n  args: CallExpressionArgument[] = [],\n): CallExpression => ({\n  type: 'CallExpression',\n  callee: {\n    type: 'FunctionIdentifier',\n    name: callee,\n  },\n  args,\n})\n\nexport const makeBashSafeVariableName = (name: string) =>\n  name.replace(/[^a-zA-Z_][^a-zA-Z_0-9]*/g, '_')\n\nexport const makeBashSafeFunctionName = (name: string) =>\n  name.replace(/^[^a-zA-Z_]/g, '_')\n","export type IdentifierLookup =\n  | ImportedFunctionIdentifierLookup\n  | FunctionIdentifierLookup\n  | VariableIdentifierLookup\n\nexport type ImportedFunctionIdentifierLookup = {\n  name: string\n  bashName: string\n  lookupKind: 'IMPORTED_FUNCTION'\n  importedFrom: string\n  scopeName: string\n}\n\nexport type FunctionIdentifierLookup = {\n  name: string\n  bashName: string\n  lookupKind: 'FUNCTION'\n  scopeName: string\n}\n\nexport type VariableIdentifierLookup = {\n  name: string\n  bashName: string\n  lookupKind: 'VARIABLE'\n  scopeName: string\n}\n\nexport class Scope {\n  parentScope: Scope\n  /**\n   * a bash-sanitized name for the scope\n   */\n  name: string\n  byTSName = new Map<string, IdentifierLookup>()\n  byBashName = new Map<string, IdentifierLookup>()\n  type: 'FUNCTION' | 'FILE'\n\n  get path(): string[] {\n    return this.isRoot ? [this.name] : [...this.parentScope.path, this.name]\n  }\n\n  get fullName(): string {\n    return this.path.join('.')\n  }\n\n  anonymousId = 0\n\n  getNextAnonymousId() {\n    return `anonymous.${++this.anonymousId}`\n  }\n\n  constructor({\n    parentScope,\n    name,\n    type,\n  }: {\n    parentScope?: Scope\n    name: string\n    type: 'FUNCTION' | 'FILE'\n  }) {\n    this.parentScope = parentScope ?? this\n    this.name = name\n    this.type = type\n  }\n\n  get isRoot() {\n    return this.parentScope === this\n  }\n\n  get(\n    key: string,\n    {\n      skipRoot = false,\n      keyType = 'byTSName',\n    }: {skipRoot?: boolean; keyType?: 'byBashName' | 'byTSName'} = {},\n  ): IdentifierLookup | undefined {\n    return skipRoot && this.isRoot\n      ? undefined\n      : this[keyType].get(key) ??\n          (this.isRoot\n            ? undefined\n            : this.parentScope.get(key, {skipRoot, keyType}))\n  }\n\n  has(\n    key: string,\n    {\n      skipRoot = false,\n      keyType = 'byTSName',\n    }: {skipRoot?: boolean; keyType?: 'byBashName' | 'byTSName'} = {},\n  ): boolean {\n    return skipRoot && this.isRoot\n      ? false\n      : this[keyType].has(key) ??\n          (this.isRoot\n            ? undefined\n            : this.parentScope.has(key, {skipRoot, keyType}))\n  }\n\n  populate(list: readonly IdentifierLookup[]) {\n    const warnings: any[] = []\n    list.forEach((item) => {\n      const previousItem = this.get(item.name)\n      if (previousItem) {\n        warnings.push({\n          type: 'IdentifierShadowing',\n          message: `The identifier ${item.name} (${item.lookupKind}) is shadowing another element (${previousItem.lookupKind})`,\n        })\n      }\n\n      const value =\n        this.type === 'FUNCTION' && item.lookupKind === 'FUNCTION'\n          ? {\n              ...item,\n              bashName: `${this.name}.${item.bashName}`,\n            }\n          : item\n\n      this.byTSName.set(value.name, value)\n\n      this.byBashName.set(value.bashName, value)\n    })\n    return {warnings}\n  }\n}\n","import * as ts from 'typescript'\nimport * as Bash from './ast/bash-ast'\nimport {\n  AllBashASTNodes,\n  getChildrenRecursively,\n  makeBashSafeFunctionName,\n  makeBashSafeVariableName,\n  makeCallExpression,\n} from './ast/bash-ast'\nimport {uniqBy} from 'ramda'\nimport {IdentifierLookup, Scope} from './scope'\n\nexport type Kinds = keyof typeof ts.SyntaxKind\n\n// https://github.com/microsoft/TypeScript/issues/37574:\nexport const SyntaxKind = Object.fromEntries(\n  Object.entries(ts.SyntaxKind).reduce<[number, Kinds][]>(\n    (result, [key, value]) =>\n      // only sequential\n      typeof value === 'number' &&\n      value > (result[result.length - 1]?.[0] ?? -1)\n        ? [...result, [value, (key as unknown) as Kinds]]\n        : result,\n    [],\n  ),\n)\n\ntype Result = {\n  nodes?: readonly Bash.AllBashASTNodes[]\n  errors?: readonly any[]\n  warnings?: readonly any[]\n}\n\ntype ResultResolver = Result | ((scope: Scope) => Result)\ntype Processed = {\n  scopeInfo?: readonly IdentifierLookup[]\n  result: Result | ((scope: Scope) => Result)\n}\n\n// TODO: maybe Result and Processed should be unified and we just run it until result contains no more functions?\n// i.e. we can always return either {scopeInfo, result: {nodes, errors, scopeInfo}},\n// or 'result' could be a function that returns {scopeInfo, result: {nodes, errors}}\n// (or a function that returns it...)\n// this way we could build the scopeInfo gradually\n\ntype MergedScopeResults = {\n  scopeInfo: readonly IdentifierLookup[]\n  resultResolvers: readonly ResultResolver[]\n}\n\ninterface TranslateTsAstToBashAstParams {\n  tsNodes: readonly ts.Node[]\n  scope: Scope\n  visitorOverrides?: Visitors\n}\n\nexport const translateTsAstToBashAst = ({\n  tsNodes,\n  scope,\n  visitorOverrides = {},\n}: TranslateTsAstToBashAstParams): Result => {\n  const {scopeInfo = [], resultResolvers = []} = tsNodes.reduce(\n    (merged: MergedScopeResults, node: ts.Node): MergedScopeResults => {\n      const {scopeInfo = [], result} = processTsNode({\n        node: node,\n        scope,\n        visitorOverrides,\n      })\n      return {\n        scopeInfo: [...(merged.scopeInfo ?? []), ...scopeInfo],\n        resultResolvers: [...(merged.resultResolvers ?? []), result],\n      }\n    },\n    {} as MergedScopeResults,\n  )\n\n  const {warnings} = scope.populate(scopeInfo)\n\n  const results: Result[] = resultResolvers.map((result) =>\n    typeof result === 'function' ? result(scope) : result,\n  )\n\n  return results.reduce(\n    (result: Result, {errors = [], nodes = [], warnings = []}) => ({\n      errors: [...(result.errors ?? []), ...errors],\n      warnings: [...(result.warnings ?? []), ...warnings],\n      nodes: [...(result.nodes ?? []), ...nodes],\n    }),\n    {warnings} as Result,\n  )\n}\n\ntype Visitors = {\n  [Key in Kinds]?: (\n    node: any,\n    parentScope: Scope,\n    visitorOverrides?: Visitors,\n  ) => Processed\n}\n\nconst VISITORS: Visitors = {\n  SourceFile: (sourceFile: ts.SourceFile, parentScope, visitorOverrides) => {\n    const {nodes, errors} = translateTsAstToBashAst({\n      tsNodes: sourceFile.statements,\n      scope: parentScope,\n      visitorOverrides,\n    })\n    return {\n      result: {\n        nodes: [\n          {\n            type: 'File',\n            statements: nodes,\n            // TODO: need to sort by: imports, functions, vars, expressions (?)\n            // .getChildren()\n            // .flatMap((child) => tsNodeToBashNode(child)) as Array<FileExpression>,\n          } as Bash.BashFile,\n        ],\n        errors,\n      },\n    }\n  },\n\n  ImportDeclaration: (\n    importDeclaration: ts.ImportDeclaration,\n    scope: Scope,\n  ): Processed => {\n    const nodes: Bash.AllBashASTNodes[] = []\n    const scopeInfo: IdentifierLookup[] = []\n    const errors: any[] = []\n    const {importClause, moduleSpecifier} = importDeclaration\n    const importedFrom = (moduleSpecifier as ts.StringLiteral).text\n    if (importClause) {\n      const {\n        // default import:\n        name,\n        // named imports\n        namedBindings,\n      } = importClause\n      if (name) {\n        errors.push({\n          type: 'UnsupportedSyntax',\n          message: 'Default imports are not supported',\n        })\n      }\n      if (namedBindings) {\n        if (namedBindings.kind === ts.SyntaxKind.NamespaceImport) {\n          errors.push({\n            type: 'UnsupportedSyntax',\n            message: 'Namespace imports are not supported',\n          })\n        } else {\n          const {elements} = namedBindings\n          elements.forEach((importSpecifier) => {\n            if (importSpecifier.propertyName) {\n              errors.push({\n                type: 'UnsupportedSyntax',\n                message: `Importing 'as' is not supported`,\n              })\n            }\n            const elementBeingImported = importSpecifier.name.text\n            scopeInfo.push({\n              importedFrom,\n              name: elementBeingImported,\n              // TODO: need to use TS type information to infer if imported type was a const or a function\n              // for now we can assume CAPITALIZED imports are variables\n              lookupKind: 'IMPORTED_FUNCTION',\n              // for now we don't need to makeBashSafeFunctionName(elementBeingImported) because\n              // we don't support renaming yet!\n              bashName: elementBeingImported,\n              scopeName: scope.name,\n            })\n          })\n        }\n      }\n    }\n    return {\n      result: {\n        errors,\n        nodes,\n      },\n      scopeInfo,\n    }\n  },\n\n  ExpressionStatement: (\n    expressionStatement: ts.ExpressionStatement,\n    scope: Scope,\n    visitorOverrides,\n  ) => {\n    return processTsNode({\n      node: expressionStatement.expression,\n      scope,\n      visitorOverrides,\n    })\n  },\n\n  ReturnStatement: (statement: ts.ReturnStatement, scope, visitorOverrides) => {\n    const {expression} = statement\n    if (!expression) {\n      return {\n        result: {\n          nodes: [makeCallExpression('return')],\n        },\n      }\n    }\n    // currently, just execute the return expression\n    return processTsNode({\n      node: expression,\n      scope,\n      visitorOverrides,\n    })\n  },\n\n  CallExpression: (\n    callExpression: ts.CallExpression,\n    parentScope: Scope,\n    visitorOverrides,\n  ): Processed => {\n    const nodes: Bash.AllBashASTNodes[] = []\n    const scopeInfo: IdentifierLookup[] = []\n    const errors: any[] = []\n\n    const {expression, arguments: args} = callExpression\n    if (expression.kind !== ts.SyntaxKind.Identifier) {\n      return {\n        result: {\n          errors: [\n            {\n              type: 'UnsupportedSyntax',\n              message: `The call must be invoked on an Identifier, but it was a ${\n                SyntaxKind[expression.kind]\n              }.`,\n            },\n          ],\n        },\n      }\n    }\n    const id = expression as ts.Identifier\n    const callee = id.text\n    // TODO: probably should add @fromModule to scope\n    return {\n      result: (scope: Scope): Result => {\n        const lookup = scope.get(callee) ?? {\n          name: callee,\n          lookupKind: 'FUNCTION',\n          scopeName: 'Global',\n        }\n        // if (!lookup) {\n        //   return {\n        //     errors: [\n        //       {\n        //         type: 'ReferenceError',\n        //         message: `Unable to find '${callee}' in scope.`,\n        //       },\n        //     ],\n        //   }\n        // }\n        const {\n          nodes: processedArgs = [],\n          errors = [],\n        } = translateTsAstToBashAst({\n          tsNodes: args,\n          scope,\n          visitorOverrides,\n        })\n        if (lookup.lookupKind === 'IMPORTED_FUNCTION') {\n          const callExpression: Bash.CallExpression = {\n            type: 'CallExpression',\n            callee: {\n              type: 'FunctionIdentifier',\n              name: '@fromModule',\n            },\n            args: [\n              {\n                type: 'StringLiteral',\n                value: lookup.importedFrom,\n              },\n              {\n                type: 'StringLiteral',\n                value: lookup.name,\n              },\n              // ... now remaining other args\n              ...(processedArgs as Bash.CallExpressionArgument[]),\n            ],\n          }\n          return {\n            nodes: [callExpression],\n            errors,\n          }\n        } else if (lookup.lookupKind === 'FUNCTION') {\n          const callExpression: Bash.CallExpression = {\n            type: 'CallExpression',\n            callee: {\n              type: 'FunctionIdentifier',\n              name: lookup.name,\n            },\n            args: [\n              // ... now remaining other args\n              ...(processedArgs as Bash.CallExpressionArgument[]),\n            ],\n          }\n          return {\n            nodes: [callExpression],\n            errors,\n          }\n        } else if (lookup.lookupKind === 'VARIABLE') {\n          const callExpression: Bash.CallExpression = {\n            type: 'CallExpression',\n            callee: {\n              type: 'FunctionIdentifier',\n              name: '@callVar',\n            },\n            args: [\n              {\n                type: 'StringLiteral',\n                value: lookup.name,\n                // TODO: support calling imported variables\n              },\n              // ... now remaining other args\n              ...(processedArgs as Bash.CallExpressionArgument[]),\n            ],\n          }\n          return {\n            nodes: [callExpression],\n            errors,\n          }\n        }\n        return {}\n      },\n    }\n  },\n\n  StringLiteral: (literal: ts.StringLiteral) => {\n    return {\n      result: {\n        nodes: [\n          {\n            type: 'StringLiteral',\n\n            value: literal.text,\n          },\n        ],\n      },\n    }\n  },\n\n  NumericLiteral: (literal: ts.NumericLiteral) => {\n    return {\n      result: {\n        nodes: [\n          {\n            type: 'NumericLiteral',\n            value: literal.text,\n          },\n        ],\n      },\n    }\n  },\n\n  VariableStatement: (\n    statement: ts.VariableStatement,\n    parentScope,\n    visitorOverrides,\n  ) => {\n    const {declarationList} = statement\n    return {\n      result: translateTsAstToBashAst({\n        tsNodes: declarationList.declarations,\n        scope: parentScope,\n        visitorOverrides,\n      }),\n    }\n  },\n\n  VariableDeclaration: (\n    declaration: ts.VariableDeclaration,\n    parentScope,\n    visitorOverrides,\n  ) => {\n    const {name: nameIdentifier, initializer} = declaration\n\n    if (initializer && SyntaxKind[initializer.kind] === 'ArrowFunction') {\n      return VISITORS.FunctionDeclaration!(\n        {...initializer, name: nameIdentifier},\n        parentScope,\n        visitorOverrides,\n      )\n    }\n\n    const {\n      nodes: initializerNodes = [],\n      errors: initializerErrors = [],\n    } = initializer\n      ? translateTsAstToBashAst({\n          tsNodes: [initializer],\n          // TODO: likely a new scope that doesn't infect this one\n          scope: parentScope,\n          visitorOverrides,\n        })\n      : {}\n    const errors = [...initializerErrors]\n    if (initializerNodes.length > 1) {\n      errors.push({\n        type: 'UnsupportedSyntax',\n        message: `Initializer contained more than 1 node, which is not supported yet: ${initializerNodes\n          .map((n) => n.type)\n          .join(', ')}`,\n      })\n    }\n\n    let [bashInitializer] = initializerNodes\n\n    if (bashInitializer?.type === 'CallExpression') {\n      // wrap a CallExpression in a CallReference when in initializer position\n      bashInitializer = {\n        type: 'CallReference',\n        quoted: true,\n        expression: bashInitializer,\n      } as Bash.CallReference\n    }\n\n    if (nameIdentifier.kind !== ts.SyntaxKind.Identifier) {\n      errors.push({\n        type: 'UnsupportedSyntax',\n        message: `Identifier is an unsupported kind: ${\n          SyntaxKind[nameIdentifier.kind]\n        }`,\n      })\n      return {result: {errors}}\n    }\n    const {text: name} = nameIdentifier\n    return {\n      result: {\n        nodes: [\n          {\n            type: 'VariableDeclaration',\n            identifier: {\n              type: 'VariableIdentifier',\n              name,\n            },\n            initializer: bashInitializer as Bash.AssignmentValue,\n          },\n        ],\n        errors,\n      },\n      scopeInfo: [\n        {\n          name,\n          lookupKind: 'VARIABLE',\n          scopeName: parentScope.name,\n          bashName: makeBashSafeVariableName(name),\n        },\n      ],\n    }\n  },\n\n  ArrowFunction: (\n    arrowFn: ts.ArrowFunction,\n    scope: Scope,\n    visitorOverrides,\n  ) => {\n    return VISITORS.FunctionDeclaration!(\n      {...arrowFn, name: {text: scope.getNextAnonymousId()}},\n      scope,\n      visitorOverrides,\n    )\n  },\n\n  FunctionDeclaration: (\n    functionDeclaration: ts.FunctionDeclaration,\n    parentScope: Scope,\n    visitorOverrides,\n  ): Processed => {\n    const {name, body, parameters} = functionDeclaration\n    const errors: any[] = []\n    if (!name) {\n      errors.push({\n        type: 'IncompleteSyntax',\n        message: `Missing name for: ${SyntaxKind[functionDeclaration.kind]}`,\n      })\n    }\n    if (!body) {\n      errors.push({\n        type: 'IncompleteSyntax',\n        message: `Missing body for: ${SyntaxKind[functionDeclaration.kind]}`,\n      })\n    }\n    if (!name || !body) return {result: {errors}}\n    const originalFnName = name.text\n    const bashFnName = makeBashSafeFunctionName(originalFnName)\n    const fnScope = new Scope({parentScope, name: bashFnName, type: 'FUNCTION'})\n    return {\n      result: (): Result => {\n        const bashParams = translateTsAstToBashAst({\n          tsNodes: parameters,\n          scope: fnScope,\n          visitorOverrides,\n        })\n        const bashStatements = translateTsAstToBashAst({\n          tsNodes: body.statements,\n          scope: fnScope,\n          visitorOverrides,\n        })\n\n        const uniqByName = uniqBy<{name: string}, string>(({name}) => name)\n\n        const {\n          nodes: nestedFunctionDeclarations,\n          statements: bashStatementNodes,\n        } = (bashStatements.nodes ?? []).reduce<{\n          statements: AllBashASTNodes[]\n          nodes: AllBashASTNodes[]\n        }>(\n          ({statements, nodes}, statement) => {\n            if (statement.type !== 'FunctionDeclaration') {\n              return {\n                statements: [...statements, statement],\n                nodes,\n              }\n            }\n            const subFnBashName = statement.name.name\n            const subFnLookup = fnScope.get(subFnBashName, {\n              keyType: 'byBashName',\n            })!\n            const subFnActualBashName = subFnLookup.bashName\n            // traverse all children (deep) to find all VariableIdentifiers except those inside other Functions\n            const children = getChildrenRecursively(statement)\n            const referencedScopedIdentifiers = uniqByName(\n              children.filter(\n                (\n                  child,\n                ): child is Bash.VariableIdentifier | Bash.FunctionIdentifier =>\n                  (child.type === 'VariableIdentifier' ||\n                    child.type === 'FunctionIdentifier') &&\n                  fnScope.has(child.name, {\n                    skipRoot: true,\n                    keyType: 'byBashName',\n                  }) &&\n                  // skip references to self\n                  child.name !== subFnActualBashName,\n              ),\n            )\n            return {\n              nodes: [\n                ...nodes,\n                {\n                  ...statement,\n                  name: {\n                    ...statement.name,\n                    name: subFnActualBashName,\n                  },\n                  statements: [\n                    ...referencedScopedIdentifiers.map((identifier, index) => ({\n                      type: 'CallExpression',\n                      callee: {\n                        type: 'FunctionIdentifier',\n                        name: 'eval',\n                      },\n                      args: [\n                        {\n                          type: 'VariableReference',\n                          quoted: true,\n                          identifier: {\n                            type: 'VariableIdentifier',\n                            name: String(index + 1),\n                          },\n                        },\n                      ],\n                    })),\n                    ...referencedScopedIdentifiers.map(() => ({\n                      type: 'CallExpression',\n                      callee: {\n                        type: 'FunctionIdentifier',\n                        name: 'shift',\n                      },\n                      args: [],\n                    })),\n                    ...statement.statements,\n                  ],\n                } as Bash.FunctionDeclaration,\n              ],\n              statements: [\n                ...statements,\n                {\n                  type: 'VariableDeclaration',\n                  identifier: {\n                    type: 'VariableIdentifier',\n                    name: '__declaration',\n                  },\n                  initializer: {\n                    type: 'ArrayLiteral',\n                    elements: [\n                      {\n                        type: 'StringLiteral',\n                        value: 'function',\n                      },\n                      {\n                        type: 'StringLiteral',\n                        value: subFnActualBashName,\n                      },\n                      ...referencedScopedIdentifiers.map((identifier) => ({\n                        type: 'CallReference',\n                        quoted: true,\n                        expression: {\n                          type: 'CallExpression',\n                          callee: {\n                            type: 'FunctionIdentifier',\n                            name: 'declare',\n                          },\n                          args: [\n                            {\n                              type: 'StringLiteral',\n                              value: '-p',\n                            },\n                            {\n                              type: 'StringLiteral',\n                              value: identifier.name,\n                            },\n                          ],\n                        },\n                      })),\n                    ],\n                  },\n                } as Bash.VariableDeclaration,\n              ],\n            }\n          },\n          {statements: [], nodes: []} as {\n            statements: Bash.FunctionBodyExpression[]\n            nodes: AllBashASTNodes[]\n          },\n        )\n\n        // the function might have been renamed, so we use the name from scope\n        const fnLookup = fnScope.get(originalFnName)!\n\n        return {\n          nodes: [\n            {\n              type: 'FunctionDeclaration',\n              name: {\n                type: 'FunctionIdentifier',\n                name: fnLookup.bashName,\n              },\n              parameters: (bashParams.nodes ?? []) as Bash.Parameter[],\n              statements: bashStatementNodes as Bash.FunctionBodyExpression[],\n            },\n            ...nestedFunctionDeclarations,\n          ],\n          errors: [\n            ...(bashParams.errors ?? []),\n            ...(bashStatements.errors ?? []),\n          ],\n        }\n      },\n      scopeInfo: [\n        {\n          scopeName: parentScope.name,\n          name: originalFnName,\n          lookupKind: 'FUNCTION',\n          bashName: bashFnName,\n        },\n      ],\n    }\n  },\n\n  Identifier: (identifier: ts.Identifier, parentScope) => {\n    return {\n      result: (scope) => {\n        const lookup = scope.get(identifier.text)\n        if (!lookup) {\n          return {\n            errors: [\n              {\n                type: 'ReferenceError',\n                message: `Unable to find '${identifier.text}' in scope.`,\n              },\n            ],\n          }\n        }\n        return {\n          nodes: [\n            lookup.lookupKind === 'VARIABLE'\n              ? {\n                  type: 'VariableReference',\n                  quoted: true,\n                  identifier: {\n                    type: 'VariableIdentifier',\n                    name: lookup.bashName,\n                  },\n                }\n              : {\n                  type: 'FunctionIdentifier',\n                  name: lookup.bashName,\n                },\n          ],\n        }\n      },\n    }\n  },\n\n  // Parameter: (parameter: ts.ParameterDeclaration) => {\n  //   // TODO\n  //   return {result: {}}\n  // },\n}\n\nfunction unimplementedVisitor(node: ts.Node): Processed {\n  return {\n    result: {\n      errors: [\n        {\n          type: 'UnsupportedSyntax',\n          message: `Visitor for ${SyntaxKind[node.kind]} is not supported yet`,\n        },\n      ],\n    },\n    scopeInfo: [],\n  }\n}\n\ninterface ProcessTsNodeParams {\n  node: ts.Node\n  scope: Scope\n  visitorOverrides?: Visitors\n}\n\nexport function processTsNode({\n  node,\n  scope,\n  visitorOverrides = {},\n}: ProcessTsNodeParams): Processed {\n  const syntaxKind = SyntaxKind[node.kind]\n  const visitor = visitorOverrides[syntaxKind] ?? VISITORS[syntaxKind]\n  if (!visitor) {\n    return unimplementedVisitor(node)\n  }\n  return visitor(node, scope)\n}\n\n// IDEA: maybe it could be using 'typescript' directly as a TS plugin?\n// then we could also add red squiggly marks for not implemented features, by node type in a given position!\n// https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\n","import * as ts from 'typescript'\nimport {translateTsAstToBashAst} from './visitors'\nimport {write} from './ast/bash-ast'\nimport {Scope} from './scope'\n\nexport function transpile(sourceFile: ts.SourceFile) {\n  const {nodes: [bashAst] = [], errors, warnings} = translateTsAstToBashAst({\n    tsNodes: [sourceFile],\n    scope: new Scope({type: 'FILE', name: sourceFile.fileName}),\n  })\n  const output = write(bashAst)\n  console.log(errors)\n  console.log(warnings)\n  return output\n}\n\nexport function transpileCode(code: string, fileName = 'default.ts') {\n  const sourceFile: ts.SourceFile = ts.createSourceFile(\n    fileName,\n    code,\n    ts.ScriptTarget.ESNext,\n    true,\n    ts.ScriptKind.TS,\n  )\n  return transpile(sourceFile)\n}\n","import './index.css'\nimport {transpileCode} from '../src/transpile'\n\nexport const transpileText = (text: string) => {\n  try {\n    return transpileCode(text)\n  } catch {\n    return undefined\n  }\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => [];\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 13411;\nmodule.exports = webpackEmptyContext;"],"sourceRoot":""}